<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | O's World]]></title>
  <link href="http://orinchen.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://orinchen.github.io/"/>
  <updated>2014-12-23T20:59:10+08:00</updated>
  <id>http://orinchen.github.io/</id>
  <author>
    <name><![CDATA[Orin Chen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS 7 交互式过渡]]></title>
    <link href="http://orinchen.github.io/blog/2014/04/11/ios7-interactive-transitions/"/>
    <updated>2014-04-11T10:04:52+08:00</updated>
    <id>http://orinchen.github.io/blog/2014/04/11/ios7-interactive-transitions</id>
    <content type="html"><![CDATA[<p>本文转载自:<a href="http://nonomori.farbox.com/post/ios-7-jiao-hu-shi-guo-du">NONOMORI</a></p>

<p>iOS 7 新加入了一个介于 ViewController 之间的过渡的实现方法。本文将介绍如何利用自定义的过渡实现如图所示效果。</p>

<p><img src="/images/posts/2014-04-11-ios7-interactive-transitions/001.gif"></p>

<p>在这个例子中，我们将在两个 ViewConrtoller 的转换过程中加入一个自定义的过渡。DSLFirstViewController 是我们的第一个 viewController，其包含一个 CollectionView，每一个 Cell 都包含一张图片和一个标签。DSLSecondViewController 是我们的第二个 viewController，其上有一张图和一个标签。我们希望，当用户点击 DSLFirstViewController 的 Cell 后能平滑过渡到 DSLSecondViewController 中去。</p>

<p>这个例子源代码已发布在 <a href="https://github.com/PeteC/InteractiveViewControllerTransitions">GitHub</a>。</p>

<!--more-->


<h2>实现自定义过渡</h2>

<p>过渡是由使用了 UIViewControllerAnimatedTransitioning 协议的对象来实现的。我们现在新建一个继承自 NSObject 的类，取名 DSLTransitionFromFirstToSecond。将上面提到的协议加入该类，然后就可以使用他来实现我们的两个类的过渡效果了。</p>

<p>在这个对象中，有两个方法需要实现：<code>animateTransition:</code> 和 <code>transitionDuration:</code>。后者相当直观，就是这个过渡的持续时间，我们只要简单返回一个 NSTimeInterval 值就行。</p>

<pre><code class="objc">- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {
    return 0.3;
}
</code></pre>

<p>animateTransition: 方法是定义两个 ViewController 之间过渡效果的地方。这个方法会传递给我们一个参数，该参数可以让我们访问一些实现过渡所必须的对象。</p>

<ul>
<li>viewControllerForKey：我们可以通过他访问过渡的两个 ViewController。</li>
<li>containerView：两个 ViewController 的 containerView。</li>
<li>initialFrameForViewController 和 finalFrameForViewController 是过渡开始和结束时每个 ViewController 的 frame。</li>
</ul>


<p>现在我们开始这个方法的具体实现。首先我们需要得到过渡前后两个 ViewController 以及他们的 containerView 的指针。</p>

<pre><code class="objc">- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {
    DSLFirstViewController *fromViewController = (DSLFirstViewController*)[transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
    DSLSecondViewController *toViewController = (DSLSecondViewController*)[transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];

    UIView *containerView = [transitionContext containerView];
</code></pre>

<p>接下来，获得我们需要过渡的 Cell，并且对它上面的 imageView 截图。这个截图就会用在我们的过渡效果中。同时，我们将这个 imageView 本身隐藏，从而让用户以为是 imageView 在移动的。</p>

<pre><code class="objc">    // 获得cell上imageView的截图
    DSLThingCell *cell = (DSLThingCell*)[fromViewController.collectionView cellForItemAtIndexPath:[[fromViewController.collectionView indexPathsForSelectedItems] firstObject]];
    UIView *cellImageSnapshot = [cell.imageView snapshotView];
    cellImageSnapshot.frame = [containerView convertRect:cell.imageView.frame fromView:cell.imageView.superview];
    cell.imageView.hidden = YES;
</code></pre>

<p>然后，我们对第二个 viewController 进行设置，将它的放到过渡后的位置，但让他完全透明，我们会在过渡时给它一个淡入的效果。</p>

<pre><code class="objc">    // 初始化一开始的状态
    toViewController.view.frame = [transitionContext finalFrameForViewController:toViewController];
    toViewController.view.alpha = 0;
    toViewController.imageView.hidden = YES;

    [containerView addSubview:toViewController.view];
    [containerView addSubview:cellImageSnapshot];
</code></pre>

<p>现在来做 view 的动画，移动之前生成的 imageView 的截图，淡入第二个 viewController 的 view。在动画结束后，移除 imageView 的截图，让第二个 view 完全呈现。</p>

<pre><code class="objc">    [UIView animateWithDuration:duration animations:^{
        // 淡入第二个viewController的view
        toViewController.view.alpha = 1.0;

        // 将截图放到第二个viewController的imageView上
        CGRect frame = [containerView convertRect:toViewController.imageView.frame fromView:toViewController.view];
        cellImageSnapshot.frame = frame;
    } completion:^(BOOL finished) {
        // Clean up
        toViewController.imageView.hidden = NO;
        cell.hidden = NO;
        [cellImageSnapshot removeFromSuperview];

        // 声明过渡结束
        [transitionContext completeTransition:!transitionContext.transitionWasCancelled];
    }];
}
</code></pre>

<p>记住，一定别忘了在过渡结束时调用 <code>completeTransition:</code> 这个方法。</p>

<h2>使用自定义过渡</h2>

<p>到目前为止，我们实现了自定义过渡对象，不过我们并没有告知 UINavigationController 去使用它。接下来，将介绍我们如何做到这一点。</p>

<p>当一个新的 viewController 被推入或者弹出它的导航堆，它将询问它的代理，是否有一个使用了 UIViewCOntrollerAnimatedTransitioning 协议的对象，我们现在要做的，就是提供这个对象使得过渡能够展现。</p>

<p>首先是把 UINavigationControllerDelegate 协议加入到 DSLFirstViewController 中去。</p>

<pre><code class="objc">@interface DSLFirstViewController ()&lt;UINavigationControllerDelegate&gt;
</code></pre>

<p>我们还需要给 navigationController 的 delegate 赋值。一个比较理想的地方是在 <code>viewDidAppear:</code>。</p>

<pre><code class="objc">- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];

    // 让我自己变成navigationController的delegate
    self.navigationController.delegate = self;
}
</code></pre>

<p>别忘了在 view 消失时，把 navigationController 的 delegate 去除。</p>

<pre><code class="objc">- (void)viewWillDisappear:(BOOL)animated {
    [super viewWillDisappear:animated];

    // 我不再是 navigationController 的代理啦
    if (self.navigationController.delegate == self) {
        self.navigationController.delegate = nil;
    }
}
</code></pre>

<p>现在我们可以开始实现这个长长名字的 UINavigationControllerDelegate 的方法。</p>

<pre><code class="objc">- (id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController
                                  animationControllerForOperation:(UINavigationControllerOperation)operation
                                               fromViewController:(UIViewController *)fromVC
                                                 toViewController:(UIViewController *)toVC {
    // 检查一下是不是过渡到DSLSecondViewController
    if (fromVC == self &amp;&amp; [toVC isKindOfClass:[DSLSecondViewController class]]) {
        return [[DSLTransitionFromFirstToSecond alloc] init];
    }
    else {
        return nil;
    }
}
</code></pre>

<p>That’s it. 当第二个 viewController 被推入进来时，navigationController 将使用我们自定义的过渡。</p>

<p>要实现弹回时的过渡效果，还是一样的方法，实现一个新的 DSLTransitionFromSecondToFirst 类用来过渡即可。</p>

<h2>让过渡变得可以交互</h2>

<p>现在我们有自定义过渡了，是时候加入交互了。我们希望让这个过渡在用户手指从屏幕左边边缘划入时产生互动。为了做到这点，我们将使用一个 iOS 7 新加入的手势识别器， <code>UIScreenEdgePanGestureRecognizer</code>。</p>

<p>我们在第二个 viewController 的 viewDidLoad 方法中，创建这个手势识别器。</p>

<pre><code class="objc">- (void)viewDidLoad {
    [super viewDidLoad];

    ...

    UIScreenEdgePanGestureRecognizer *popRecognizer = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(handlePopRecognizer:)];
    popRecognizer.edges = UIRectEdgeLeft;
    [self.view addGestureRecognizer:popRecognizer];
}
</code></pre>

<p>现在我们可以识别该手势了，我们用它来设置并更新一个 iOS 7 新加入的类的对象。 UIPercentDrivenInteractiveTransition。这个类的对象会根据我们的手势，来决定我们的自定义过渡的完成度。我们把这些都放到手势识别器的 action 方法中去，具体就是：</p>

<p>当手势刚刚开始，我们创建一个 UIPercentDrivenInteractiveTransition 对象，然后让 navigationController 去把当前这个 viewController 弹出。</p>

<p>当手慢慢划入时，我们把总体手势划入的进度告诉 UIPercentDrivenInteractiveTransition 对象。</p>

<p>当手势结束，我们根据用户的手势进度来判断过渡是应该完成还是取消并相应的调用 <code>finishInteractiveTransition</code> 或者 <code>cancelInteractiveTransition</code> 方法.</p>

<pre><code class="objc">- (void)handlePopRecognizer:(UIScreenEdgePanGestureRecognizer*)recognizer {
    // 计算用户手指划了多远
    CGFloat progress = [recognizer translationInView:self.view].x / (self.view.bounds.size.width * 1.0);
    progress = MIN(1.0, MAX(0.0, progress));

    if (recognizer.state == UIGestureRecognizerStateBegan) {
        // 创建过渡对象，弹出viewController
        self.interactivePopTransition = [[UIPercentDrivenInteractiveTransition alloc] init];
        [self.navigationController popViewControllerAnimated:YES];
    }
    else if (recognizer.state == UIGestureRecognizerStateChanged) {
        // 更新 interactive transition 的进度
        [self.interactivePopTransition updateInteractiveTransition:progress];
    }
    else if (recognizer.state == UIGestureRecognizerStateEnded || recognizer.state == UIGestureRecognizerStateCancelled) {
        // 完成或者取消过渡
        if (progress &gt; 0.5) {
            [self.interactivePopTransition finishInteractiveTransition];
        }
        else {
            [self.interactivePopTransition cancelInteractiveTransition];
        }

        self.interactivePopTransition = nil;
    }
}
</code></pre>

<p>现在我们可以创建并更新 UIPercentDrivenInteractiveTransition 对象了，我们需要告诉 navigationController 去用它。为此，我们需要实现另一个 UInavigationControllerDelegate 的方法。</p>

<pre><code class="objc">- (id&lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController
                         interactionControllerForAnimationController:(id&lt;UIViewControllerAnimatedTransitioning&gt;)animationController {
    // 检查是否是我们的自定义过渡
    if ([animationController isKindOfClass:[DSLTransitionFromSecondToFirst class]]) {
        return self.interactivePopTransition;
    }
    else {
        return nil;
    }
}
</code></pre>

<p>至此，我们第二个 viewController 回到第一个 viewController 的过渡就可以交互了。</p>

<h2>尾声</h2>

<p>希望这篇文章能帮你理解如何创建你自己的自定义过渡及其交互。文中例子的工程文件已上传至 <a href="https://github.com/PeteC/InteractiveViewControllerTransitions">GitHub</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈 Objective-C Block 的实现]]></title>
    <link href="http://orinchen.github.io/blog/2014/03/26/a-look-inside-blocks/"/>
    <updated>2014-03-26T14:09:38+08:00</updated>
    <id>http://orinchen.github.io/blog/2014/03/26/a-look-inside-blocks</id>
    <content type="html"><![CDATA[<p>本文转载自:<a href="http://blog.devtang.com/blog/2013/07/28/a-look-inside-blocks/">唐巧的技术博客</a></p>

<h2>前言</h2>

<p><a href="http://blog.parse.com/2013/02/05/objective-c-blocks-quiz/">这里</a>有关于 <strong>block</strong> 的5道测试题，建议你阅读本文之前先做一下测试。</p>

<p>先介绍一下什么是闭包。在 Wikipedia 上，<a href="http://en.wikipedia.org/wiki/Closure_(computer_science">闭包的定义</a>)是:</p>

<blockquote><p>In programming languages, a closure is a function or reference to a function together with a referencing environment—a table storing a reference to each of the non-local variables (also called free variables or upvalues) of that function.</p></blockquote>

<p>翻译过来就是：</p>

<blockquote><p>闭包是一个函数（或指向函数的指针），再加上该函数执行的外部的上下文变量（有时候也称作自由变量）。</p></blockquote>

<p><strong>block</strong> 实际上就是 Objective-C 语言对于闭包的实现。 <strong>block</strong> 配合上 <strong>dispatch_queue</strong>，可以方便地实现简单的多线程编程和异步编程，关于这个，我之前写过一篇文章介绍：<a href="http://blog.devtang.com/blog/2012/02/22/use-gcd/">《使用GCD》</a>。</p>

<p>本文主要介绍 Objective-C 语言的 <strong>block</strong> 在编译器中的实现方式。主要包括：</p>

<ol>
<li><strong>block</strong> 的内部实现数据结构介绍</li>
<li><strong>block</strong> 的三种类型及其相关的内存管理方式</li>
<li><strong>block</strong> 如何通过 <strong>capture</strong> 变量来达到访问函数外的变量</li>
</ol>


<!--more-->


<h2>实现方式</h2>

<h3>数据结构定义</h3>

<p>block的数据结构定义如下（图片来自<a href="http://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/">这里</a>)：</p>

<p><img src="/images/posts/2014-03-26-a-look-inside-blocks/block-struct.jpg"></p>

<p>对应的结构体定义如下：</p>

<pre><code class="objc">struct Block_descriptor {
    unsigned long int reserved;
    unsigned long int size;
    void (*copy)(void *dst, void *src);
    void (*dispose)(void *);
};

struct Block_layout {
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(void *, ...);
    struct Block_descriptor *descriptor;
    /* Imported variables. */
};
</code></pre>

<p>通过该图，我们可以知道，一个 <strong>block</strong> 实例实际上由6部分构成：</p>

<ol>
<li><strong>isa</strong> 指针，所有对象都有该指针，用于实现对象相关的功能。</li>
<li><strong>flags</strong>，用于按 bit 位表示一些 <strong>block</strong> 的附加信息，本文后面介绍 <strong>block copy</strong> 的实现代码可以看到对该变量的使用。</li>
<li><strong>reserved</strong>，保留变量。</li>
<li><strong>invoke</strong>，函数指针，指向具体的 <strong>block</strong> 实现的函数调用地址。</li>
<li><strong>descriptor</strong>， 表示该 <strong>block</strong> 的附加描述信息，主要是 <strong>size</strong> 大小，以及 <strong>copy</strong> 和 <strong>dispose</strong>函数的指针。</li>
<li><strong>variables</strong>，<strong>capture</strong> 过来的变量，<strong>block</strong> 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。</li>
</ol>


<p>该数据结构和后面的 clang 分析出来的结构实际是一样的，不过仅是结构体的嵌套方式不一样。但这一点我一开始没有想明白，所以也给大家解释一下，如下2个结构体 SampleA 和 SampleB 在内存上是完全一样的，原因是结构体本身并不带有任何额外的附加信息。</p>

<pre><code class="objc">struct SampleA {
    int a;
    int b;
    int c;
};

struct SampleB {
    int a;
    struct Part1 {
        int b;
    };
    struct Part2 {
        int c;
    };
};
</code></pre>

<p>在 Objective-C 语言中，一共有3种类型的 <strong>block</strong>：</p>

<ol>
<li><strong>_NSConcreteGlobalBlock</strong> 全局的静态 <strong>block</strong>，不会访问任何外部变量。</li>
<li><strong>_NSConcreteStackBlock</strong> 保存在栈中的 <strong>block</strong>，当函数返回时会被销毁。</li>
<li><strong>_NSConcreteMallocBlock</strong> 保存在堆中的 <strong>block</strong>，当引用计数为0时会被销毁。</li>
</ol>


<p>我们在下面会分别来查看它们各自的实现方式上的差别。</p>

<h3>研究工具：clang</h3>

<p>为了研究编译器是如何实现 <strong>block</strong> 的，我们需要使用 clang。clang 提供一个命令，可以将 Objetive-C 的源码改写成 c 语言的，借此可以研究 <strong>block</strong> 具体的源码实现方式。该命令是</p>

<pre><code>clang -rewrite-objc block.c
</code></pre>

<h3>NSConcreteGlobalBlock 类型的 block 的实现</h3>

<p>我们先新建一个名为 block1.c 的源文件：</p>

<pre><code class="objc">#include &lt;stdio.h&gt;

int main()
{
    ^{ printf("Hello, World!\n"); } ();
    return 0;
}
</code></pre>

<p>然后在命令行中输入 <code>clang -rewrite-objc block1.c</code> 即可在目录中看到 clang 输出了一个名为 block1.cpp 的文件。该文件就是 block 在 c 语言实现，我将 block1.cpp 中一些无关的代码去掉，将关键代码引用如下：</p>

<pre><code class="objc">struct __block_impl {
    void *isa;
    int Flags;
    int Reserved;
    void *FuncPtr;
};

struct __main_block_impl_0 {
    struct __block_impl impl;
    struct __main_block_desc_0* Desc;
    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
        impl.isa = &amp;_NSConcreteStackBlock;
        impl.Flags = flags;
        impl.FuncPtr = fp;
        Desc = desc;
    }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
    printf("Hello, World!\n");
}

static struct __main_block_desc_0 {
    size_t reserved;
    size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0) };

int main()
{
    (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA) ();
    return 0;
}
</code></pre>

<p>下面我们就具体看一下是如何实现的。<strong>__main_block_impl_0</strong>  就是该 <strong>block</strong> 的实现，从中我们可以看出：</p>

<ol>
<li>一个 <strong>block</strong> 实际是一个对象，它主要由一个 <strong>isa</strong> 和 一个 <strong>impl</strong> 和 一个 <strong>descriptor</strong> 组成。</li>
<li>在本例中，<strong>isa</strong> 指向 <strong>_NSConcreteGlobalBlock</strong>， 主要是为了实现对象的所有特性，在此我们就不展开讨论了。</li>
<li>由于 clang 改写的具体实现方式和 LLVM 不太一样，并且这里没有开启 ARC。所以这里我们看到 <strong>isa</strong> 指向的还是 <strong>_NSConcreteStackBlock</strong>。但在 LLVM 的实现中，开启 ARC 时，<strong>block</strong> 应该是 <strong>_NSConcreteGlobalBlock</strong> 类型，具体可以看<a href="http://blog.parse.com/2013/02/05/objective-c-blocks-quiz/">《objective-c-blocks-quiz》</a>第二题的解释。</li>
<li><strong>impl</strong> 是实际的函数指针，本例中，它指向 <strong>__main_block_func_0</strong>。这里的 <strong>impl</strong> 相当于之前提到的 <strong>invoke</strong> 变量，只是 clang 编译器对变量的命名不一样而已。</li>
<li><strong>descriptor</strong> 是用于描述当前这个 <strong>block</strong> 的附加信息的，包括结构体的大小，需要 <strong>capture</strong> 和 <strong>dispose</strong> 的变量列表等。结构体大小需要保存是因为，每个 <strong>block</strong> 因为会 <strong>capture</strong> 一些变量，这些变量会加到 <strong>__main_block_impl_0</strong> 这个结构体中，使其体积变大。在该例子中我们还看不到相关 <strong>capture</strong> 的代码，后面将会看到。</li>
</ol>


<h3>NSConcreteStackBlock 类型的block的实现</h3>

<p>我们另外新建一个名为 block2.c 的文件，输入以下内容：</p>

<pre><code class="objc">#include &lt;stdio.h&gt;

int main() {
    int a = 100;
    void (^block2)(void) = ^{
        printf("%d\n", a);
    };
    block2();

    return 0;
}
</code></pre>

<p>用之前提到的 clang 工具，转换后的关键代码如下：</p>

<pre><code class="objc">struct __main_block_impl_0 {
    struct __block_impl impl;
    struct __main_block_desc_0* Desc;
    int a;
    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) {
        impl.isa = &amp;_NSConcreteStackBlock;
        impl.Flags = flags;
        impl.FuncPtr = fp;
        Desc = desc;
    }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
    int a = __cself-&gt;a; // bound by copy
    printf("%d\n", a);
}

static struct __main_block_desc_0 {
    size_t reserved;
    size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};

int main()
{
    int a = 100;
    void (*block2)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a);
    ((void (*)(__block_impl *))((__block_impl *)block2)-&gt;FuncPtr)((__block_impl *)block2);

    return 0;
}
</code></pre>

<p>在本例中，我们可以看到：</p>

<ol>
<li>本例中，<strong>isa</strong> 指向 <strong>_NSConcreteStackBlock</strong>，说明这是一个分配在栈上的实例。</li>
<li><strong>main_block_impl_0</strong>  中增加了一个变量 <strong>a</strong>，在 <strong>block</strong> 中引用的变量 <strong>a</strong> 实际是在申明 <strong>block</strong> 时，被复制到 <strong>main_block_impl_0</strong>结构体中的那个变量 <strong>a</strong>。因为这样，我们就能理解，在 <strong>block</strong> 内部修改变量a的内容，不会影响外部的实际变量 <strong>a</strong>。</li>
<li><strong>main_block_impl_0</strong> 中由于增加了一个变量 <strong>a</strong>，所以结构体的大小变大了，该结构体大小被写在了 <strong>main_block_desc_0</strong> 中。</li>
</ol>


<p>我们修改上面的源码，在变量前面增加 <strong>__block</strong> 关键字：</p>

<pre><code class="objc">#include &lt;stdio.h&gt;

int main()
{
    __block int i = 1024;
    void (^block1)(void) = ^{
        printf("%d\n", i);
        i = 1023;
    };
    block1();
    return 0;
}
</code></pre>

<p>生成的关键代码如下，可以看到，差异相当大：</p>

<pre><code class="objc">struct __Block_byref_i_0 {
    void *__isa;
    __Block_byref_i_0 *__forwarding;
    int __flags;
    int __size;
    int i;
};

struct __main_block_impl_0 {
    struct __block_impl impl;
    struct __main_block_desc_0* Desc;
    __Block_byref_i_0 *i; // by ref
    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&gt;__forwarding) {
        impl.isa = &amp;_NSConcreteStackBlock;
        impl.Flags = flags;
        impl.FuncPtr = fp;
        Desc = desc;
    }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
    __Block_byref_i_0 *i = __cself-&gt;i; // bound by ref

    printf("%d\n", (i-&gt;__forwarding-&gt;i));
    (i-&gt;__forwarding-&gt;i) = 1023;
}

static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);}

static struct __main_block_desc_0 {
    size_t reserved;
    size_t Block_size;
    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
    void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};

int main()
{
    __attribute__((__blocks__(byref))) __Block_byref_i_0 i = {(void*)0,(__Block_byref_i_0 *)&amp;i, 0, sizeof(__Block_byref_i_0), 1024};
    void (*block1)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;i, 570425344);
    ((void (*)(__block_impl *))((__block_impl *)block1)-&gt;FuncPtr)((__block_impl *)block1);
    return 0;
}
</code></pre>

<p>从代码中我们可以看到：</p>

<ol>
<li>源码中增加一个名为 <strong>__Block_byref_i_0</strong> 的结构体，用来保存我们要 <strong>capture</strong> 并且修改的变量 <strong>i</strong>。</li>
<li><strong>main_block_impl_0</strong> 中引用的是 <strong>Block_byref_i_0</strong> 的结构体指针，这样就可以达到修改外部变量的作用。</li>
<li><strong>__Block_byref_i_0</strong> 结构体中带有 <strong>isa</strong>，说明它也是一个对象。</li>
<li>我们需要负责 <strong>Block_byref_i_0</strong> 结构体相关的内存管理，所以 <strong>main_block_desc_0</strong> 中增加了 <strong>copy</strong> 和 <strong>dispose</strong> 函数指针，对于在调用前后修改相应变量的引用计数。</li>
</ol>


<h3>NSConcreteMallocBlock 类型的block的实现</h3>

<p><strong>NSConcreteMallocBlock</strong> 类型的 <strong>block</strong> 通常不会在源码中直接出现，因为默认它是当一个 <strong>block</strong> 被 <strong>copy</strong> 的时候，才会将这个 <strong>block</strong> 复制到堆中。以下是一个 <strong>block</strong> 被 <strong>copy</strong> 时的示例代码(来自<a href="http://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/">这里</a>)，可以看到，在第8步，目标的 <strong>block</strong> 类型被修改为 <strong>_NSConcreteMallocBlock</strong>。</p>

<pre><code class="objc">static void *_Block_copy_internal(const void *arg, const int flags) {
    struct Block_layout *aBlock;
    const bool wantsOne = (WANTS_ONE &amp; flags) == WANTS_ONE;

    // 1
    if (!arg) return NULL;

    // 2
    aBlock = (struct Block_layout *)arg;

    // 3
    if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) {
        // latches on high
        latching_incr_int(&amp;aBlock-&gt;flags);
        return aBlock;
    }

    // 4
    else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) {
        return aBlock;
    }

    // 5
    struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);
    if (!result) return (void *)0;

    // 6
    memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first

    // 7
    result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed
    result-&gt;flags |= BLOCK_NEEDS_FREE | 1;

    // 8
    result-&gt;isa = _NSConcreteMallocBlock;

    // 9
    if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) {
        (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup
    }

    return result;
}
</code></pre>

<h2>变量的复制</h2>

<p>对于 <strong>block</strong> 外的变量引用，<strong>block</strong> 默认是将其复制到其数据结构中来实现访问的，如下图所示（图片来自<a href="http://rypress.com/tutorials/objective-c/blocks.html">这里</a>）：</p>

<p><img src="/images/posts/2014-03-26-a-look-inside-blocks/block-capture-1.jpg"></p>

<p>对于用 <strong>__block</strong> 修饰的外部变量引用，<strong>block</strong> 是复制其引用地址来实现访问的，如下图所示（图片来自<a href="http://rypress.com/tutorials/objective-c/blocks.html">这里</a>）：</p>

<p><img src="/images/posts/2014-03-26-a-look-inside-blocks/block-capture-2.jpg"></p>

<h2>LLVM源码</h2>

<p>在 LLVM 开源的关于 <a href="https://llvm.org/svn/llvm-project/compiler-rt/trunk/BlocksRuntime/Block_private.h"><strong>block</strong> 的实现源码</a>，其内容也和我们用 clang 改写得到的内容相似，印证了我们对于 <strong>block</strong> 内部数据结构的推测。</p>

<h2>ARC对block类型的影响</h2>

<p>在 ARC 开启的情况下，将只会有 <strong>NSConcreteGlobalBlock</strong> 和 <strong>NSConcreteMallocBlock</strong> 类型的 <strong>block</strong>。</p>

<p>原本的 <strong>NSConcreteStackBlock</strong> 的 <strong>block</strong> 会被 <strong>NSConcreteMallocBlock</strong> 类型的 <strong>block</strong> 替代。证明方式是以下代码在 XCode 中，会输出 <code>&lt;__NSMallocBlock__: 0x100109960&gt;</code>。在苹果的官方文档中也提到，当把栈中的 <strong>block</strong> 返回时，不需要调用 <strong>copy</strong> 方法了。</p>

<pre><code class="objc">#import &lt;Foundation/Foundation.h&gt;

int main(int argc, const char * argv[])
{
    @autoreleasepool {
        int i = 1024;
        void (^block1)(void) = ^{
            printf("%d\n", i);
        };
        block1();
        NSLog(@"%@", block1);
    }
    return 0;
}
</code></pre>

<p>我个人认为这么做的原因是，由于 ARC 已经能很好地处理对象的生命周期的管理，这样所有对象都放到堆上管理，对于编译器实现来说，会比较方便。</p>

<h2>参考链接</h2>

<p>希望本文能加深你对于 <strong>block</strong> 的理解。我在学习中，查阅了以下文章，一并分享给大家。祝大家玩得开心～</p>

<ul>
<li><p><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-1">A look inside blocks: Episode 1</a></p></li>
<li><p><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-2/">A look inside blocks: Episode 2</a></p></li>
<li><p><a href="http://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/">A look inside blocks: Episode 3</a></p></li>
<li><p><a href="http://www.cnblogs.com/biosli/archive/2013/05/29/iOS_Objective-C_Block.html">对Objective-C中Block的追探</a></p></li>
<li><p><a href="https://llvm.org/svn/llvm-project/compiler-rt/trunk/BlocksRuntime/Block_private.h">LLVM中block实现源码</a></p></li>
<li><p><a href="http://blog.parse.com/2013/02/05/objective-c-blocks-quiz/">objective-c-blocks-quiz</a></p></li>
<li><p><a href="http://rypress.com/tutorials/objective-c/blocks.html">Blocks</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C对象模型及应用]]></title>
    <link href="http://orinchen.github.io/blog/2014/03/20/objective-c-object-model/"/>
    <updated>2014-03-20T10:43:32+08:00</updated>
    <id>http://orinchen.github.io/blog/2014/03/20/objective-c-object-model</id>
    <content type="html"><![CDATA[<p>本文转载自:<a href="http://blog.devtang.com/blog/2013/10/15/objective-c-object-model/">唐巧的技术博客</a></p>

<h2>前言</h2>

<p>本文主要介绍 Objective-C 对象模型的实现细节，以及 Objective-C 语言对象模型中对 <strong>isa swizzling</strong> 和 <strong>method swizzling</strong> 的支持。希望本文能加深你对 Objective-C 对象的理解。</p>

<!--more-->


<h2>ISA指针</h2>

<p>Objective-C 是一门面向对象的编程语言。每一个对象都是一个类的实例。在 Objective-C 语言的内部，每一个对象都有一个名为 <strong>isa</strong> 的指针，指向该对象的类。每一个类描述了一系列它的实例的特点，包括成员变量的列表，成员函数的列表等。每一个对象都可以接受消息，而对象能够接收的消息列表是保存在它所对应的类中。</p>

<p>在 XCode 中按 <em>Shift + Command + O</em>, 然后输入 NSObject.h 和 objc.h，可以打开 <code>NSObject</code> 的定义头文件，通过头文件我们可以看到，<code>NSObject</code> 就是一个包含 <strong>isa</strong> 指针的结构体，如下图所示：</p>

<p><img src="/images/posts/2014-03-20-objective-c-object-model/class-nsobject-isa.jpg"></p>

<p><img src="/images/posts/2014-03-20-objective-c-object-model/class-objc-object-isa.jpg"></p>

<p>按照面向对象语言的设计原则，所有事物都应该是对象（严格来说 Objective-C 并没有完全做到这一点，因为它有象 int, double 这样的简单变量类型）。在 Objective-C 语言中，每一个类实际上也是一个对象。每一个类也有一个名为 <strong>isa</strong> 的指针。每一个类也可以接受消息，例如 <code>[NSObject alloc]</code>，就是向 NSObject 这个类发送名为 <code>alloc</code> 消息。</p>

<p>在 XCode 中按 <em>Shift + Command + O</em>, 然后输入 runtime.h，可以打开 Class 的定义头文件，通过头文件我们可以看到，Class 也是一个包含 <strong>isa</strong> 指针的结构体，如下图所示。（图中除了 <strong>isa</strong> 外还有其它成员变量，但那是为了兼容非2.0版的 Objective-C 的遗留逻辑，大家可以忽略它。）</p>

<p><img src="/images/posts/2014-03-20-objective-c-object-model/class-objc-class-isa.jpg"></p>

<p>因为类也是一个对象，那它也必须是另一个类的实列，这个类就是元类(<strong>metaclass</strong>)。元类保存了类方法的列表。当一个类方法被调用时，元类会首先查找它本身是否有该类方法的实现，如果没有，则该元类会向它的父类查找该方法，直到一直找到继承链的头。</p>

<p>元类(<strong>metaclass</strong>)也是一个对象，那么元类的 <strong>isa</strong> 指针又指向哪里呢？为了设计上的完整，所有的元类的 <strong>isa</strong> 指针都会指向一个根元类(<strong>root metaclass</strong>)。根元类(<strong>root metaclass</strong>)本身的 <strong>isa</strong> 指针指向自己，这样就行成了一个闭环。上面提到，一个对象能够接收的消息列表是保存在它所对应的类中的。在实际编程中，我们几乎不会遇到向元类发消息的情况，那它的 <strong>isa</strong> 指针在实际上很少用到。不过这么设计保证了面向对象的干净，即所有事物都是对象，都有 <strong>isa</strong> 指针。</p>

<p>我们再来看看继承关系，由于类方法的定义是保存在元类(<strong>metaclass</strong>)中，而方法调用的规则是：如果该类没有一个方法的实现，则向它的父类继续查找。所以，为了保证父类的类方法可以在子类中可以被调用，所以子类的元类会继承父类的元类，换而言之，类对象和元类对象有着同样的继承关系。</p>

<p>我很想把关系说清楚一些，但是这块儿确实有点绕，下面这张图或许能够让大家对 <strong>isa</strong>和继承的关系清楚一些（该图片来自<a href="http://www.sealiesoftware.com/blog/class%20diagram.pdf">这里</a>）:</p>

<p><img src="/images/posts/2014-03-20-objective-c-object-model/class-diagram.jpg"></p>

<p>该图中，最让人困惑的莫过于 <strong>Root Class</strong> 了。在实现中，<strong>Root Class</strong> 是指 <strong>NSObject</strong>，我们可以从图中看出：</p>

<ol>
<li>NSObject 类包括它的对象实例方法。</li>
<li>NSObject 的元类包括它的类方法，例如 alloc 方法。</li>
<li>NSObject 的元类继承自 NSObject 类。</li>
<li>一个 NSObject 的类中的方法同时也会被 NSObject 的子类在查找方法时找到。</li>
</ol>


<h2>类的成员变量</h2>

<p>如果把类的实例看成一个 <strong>C</strong> 语言的结构体（<strong>struct</strong>），上面说的 <strong>isa</strong> 指针就是这个结构体的第一个成员变量，而类的其它成员变量依次排列在结构体中。排列顺序如下图所示（图片来自《iOS 6 Programming Pushing the Limits》）：</p>

<p><img src="/images/posts/2014-03-20-objective-c-object-model/class-member.jpg"></p>

<p>为了验证该说法，我们在 XCode 中新建一个工程，在 main.m 中运行如下代码：</p>

<pre><code class="objc">#import &lt;UIKit/UIKit.h&gt;

@interface Father : NSObject {
    int _father;
}

@end

@implementation Father

@end

@interface Child : Father {
    int _child;
}

@end

@implementation Child

@end

int main(int argc, char * argv[])
{
  Child * child = [[Child alloc] init];
  @autoreleasepool {
      // ...
  }
}
</code></pre>

<p>我们将断点下在 <code>@autoreleasepool</code> 处，然后在 <strong>Console</strong> 中输入 <code>p *child</code>,则可以看到 Xcode 输出如下内容，这与我们上面的说法一致。</p>

<pre><code>(lldb) p *child
(Child) $0 = {
  (Father) Father = {
    (NSObject) NSObject = {
      (Class) isa = Child
    }
    (int) _father = 0
  }
  (int) _child = 0
}
</code></pre>

<h2>可变与不可变</h2>

<p>因为对象在内存中的排布可以看成一个结构体，该结构体的大小并不能动态变化。所以无法在运行时动态给对象增加成员变量。</p>

<p>相对的，对象的方法定义都保存在类的可变区域中。Objective-C 2.0 并未在头文件中将实现暴露出来，但在 Objective-C 1.0 中，我们可以看到方法的定义列表是一个名为 <strong>methodLists</strong> 的指针的指针（如下图所示）。通过修改该指针指向的指针的值，就可以实现动态地为某一个类增加成员方法。这也是 <strong>Category</strong> 实现的原理。同时也说明了为什么 <strong>Category</strong> 只可为对象增加成员方法，却不能增加成员变量。</p>

<p><img src="/images/posts/2014-03-20-objective-c-object-model/class-objc-class-isa.jpg"></p>

<p>需要特别说明一下，通过 <code>objc_setAssociatedObject</code> 和 <code>objc_getAssociatedObject</code> 方法可以变相地给对象增加成员变量，但由于实现机制不一样，所以并不是真正改变了对象的内存结构。</p>

<p>除了对象的方法可以动态修改，因为 <strong>isa</strong> 本身也只是一个指针，所以我们也可以在运行时动态地修改 <strong>isa</strong> 指针的值，达到替换对象整个行为的目的。不过该应用场景较少。</p>

<h2>系统相关API及应用</h2>

<h3>isa swizzling 的应用</h3>

<p>系统提供的 <strong>KVO</strong> 的实现，就利用了动态地修改 <strong>isa</strong> 指针的值的技术。在苹果的文档中可以看到如下描述：</p>

<blockquote><p>Key-Value Observing Implementation Details</p>

<p>Automatic key-value observing is implemented using a technique called isa-swizzling.</p>

<p>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p>

<p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p>

<p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p></blockquote>

<h3>Method Swizzling API说明</h3>

<p>Objective-C 提供了以下 API 来动态替换类方法或实例方法的实现：</p>

<ul>
<li><code>class_replaceMethod</code> 替换类方法的定义</li>
<li><code>method_exchangeImplementations</code> 交换2个方法的实现</li>
<li><code>method_setImplementation</code> 设置1个方法的实现</li>
</ul>


<p>这 3 个方法有一些细微的差别，给大家介绍如下：</p>

<ul>
<li><code>class_replaceMethod</code> 在苹果的文档（如下图所示）中能看到，它有两种不同的行为。当类中没有想替换的原方法时，该方法会调用 <code>class_addMethod</code> 来为该类增加一个新方法，也因为如此，<code>class_replaceMethod</code> 在调用时需要传入 <code>types</code> 参数，而 <code>method_exchangeImplementations</code> 和 <code>method_setImplementation</code> 却不需要。</li>
</ul>


<p><img src="/images/posts/2014-03-20-objective-c-object-model/class-replace-method.jpg"></p>

<ul>
<li><code>method_exchangeImplementations</code> 的内部实现其实是调用了2次 <code>method_setImplementation</code> 方法，从苹果的文档中能清晰地了解到（如下图所示）</li>
</ul>


<p><img src="/images/posts/2014-03-20-objective-c-object-model/class-method-exchange-imp.jpg"></p>

<p>从以上的区别我们可以总结出这3个API的使用场景:</p>

<ul>
<li><code>class_replaceMethod</code>, 当需要替换的方法可能有不存在的情况时，可以考虑使用该方法。</li>
<li><code>method_exchangeImplementations</code>，当需要交换2个方法的实现时使用。</li>
<li><code>method_setImplementation</code> 最简单的用法，当仅仅需要为一个方法设置其实现方式时使用。</li>
</ul>


<h2>使用示例</h2>

<p>我们在开发猿题库客户端的笔记功能时，需要使用系统的 <code>UIImagePickerController</code>。但是，我们发现，在 iOS6.0.2 系统下，系统提供的 <code>UIImagePickerController</code> 在 iPad 横屏下有转屏的 Bug，造成其方向错误。具体的 Bug 详情可以见<a href="http://stackoverflow.com/questions/12522491/crash-on-presenting-uiimagepickercontroller-under-ios-6-0">这里</a>。</p>

<p>为了修复该 Bug，我们需要替换 <code>UIImagePickerController</code> 的如下2个方法</p>

<pre><code class="objc">
- (BOOL)shouldAutorotate;
- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation;
</code></pre>

<p>我们先实现了一个名为 <code>ImagePickerReplaceMethodsHolder</code> 的类，用于定义替换后的方法和实现。如下所示：</p>

<pre><code class="objc">// ImagePickerReplaceMethodsHolder.h
@interface ImagePickerReplaceMethodsHolder : NSObject

- (BOOL)shouldAutorotate;
- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation;

@end

// ImagePickerReplaceMethodsHolder.m
@implementation ImagePickerReplaceMethodsHolder

- (BOOL)shouldAutorotate {
    return NO;
}

- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation {
    return UIInterfaceOrientationPortrait;
}


@end
</code></pre>

<p>然后，我们在调用处，判断当前的 iOS 版本，对于[iOS6.0, iOS6.1)之间的版本，我们将 <code>UIImagePickerController</code> 的有问题的方法替换。具体代码如下：</p>

<pre><code class="objc">#define SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v)  ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedAscending)
#define SYSTEM_VERSION_LESS_THAN(v)                 ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedAscending)

+ (void)load {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        [self hackForImagePicker];
    });
}

+ (void)hackForImagePicker {
    // fix bug of image picker under iOS 6.0
    // http://stackoverflow.com/questions/12522491/crash-on-presenting-uiimagepickercontroller-under-ios-6-0
    if (SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(@"6.0")
        &amp;&amp; SYSTEM_VERSION_LESS_THAN(@"6.1")) {
        Method oldMethod1 = class_getInstanceMethod([UIImagePickerController class], @selector(shouldAutorotate));
        Method newMethod1 = class_getInstanceMethod([ImagePickerReplaceMethodsHolder class], @selector(shouldAutorotate));
        method_setImplementation(oldMethod1, method_getImplementation(newMethod1));

        Method oldMethod2 = class_getInstanceMethod([UIImagePickerController class], @selector(preferredInterfaceOrientationForPresentation));
        Method newMethod2 = class_getInstanceMethod([ImagePickerReplaceMethodsHolder class], @selector(preferredInterfaceOrientationForPresentation));
        method_setImplementation(oldMethod2, method_getImplementation(newMethod2));
    }
}
</code></pre>

<p>通过如上代码，我们就针对 iOS 特定版本的有问题的系统库函数打了 Patch，使问题得到解决。</p>

<h2>开源界的使用</h2>

<p>有少量不明真相的同学以为苹果在审核时会拒绝 App 使用以上 API，这其实是对苹果的误解。使用如上 API 是安全的。另外，开源界也对以上方法都适当的使用。例如：</p>

<ul>
<li><p>著名的网络库 <strong>AFNetworking</strong>。<strong>AFNetworking</strong> 网络库(v1.x版本)使用了 <code>class_replaceMethod</code> 方法（AFHTTPRequestOperation.m文件第105行）</p></li>
<li><p>Nimbus。Nimbus 是著名的工具类库，它在其 core 模块中提供了 NIRuntimeClassModifications.h文件，用于提供上述 API 的封装。</p></li>
<li><p>国内的大众点评 iOS 客户端。该客户端使用了他们自己开发的基于 Wax 修改而来的 <a href="https://github.com/mmin18/WaxPatch">WaxPatch</a>，WaxPatch 可以实现通过服务器更新来动态修改客户端的逻辑。而 WaxPatch 主要是修改了 Wax 中的 wax_instance.m文件，在其中加入了 <code>class_replaceMethod</code> 来替换原始实现，从而实现修改客户端的原有行为。</p></li>
</ul>


<h2>总结</h2>

<p>通过本文，我们了解到了 Objective-C 语言的对象模型，以及 Objective-C 语言对象模型中对 <strong>isa swizzling</strong> 和 <strong>method swizzling</strong> 的支持。本文也通过具体的实例代码和开源项目，让我们对该对象模型提供的动态性有了更加深刻的认识。</p>

<h2>后记</h2>

<p>文章发表后，一些同行指出在 ARM64 的 CP U下，<strong>isa</strong> 的内部结构有变化。这点我是知道的，不过希望以后再撰文讨论。感兴趣的同学可以查看苹果今年WWDC2013的视频：《Session 404 Advanced in Objective-C》。</p>

<h2>参考链接</h2>

<ul>
<li><p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html</a></p></li>
<li><p><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html</a></p></li>
<li><p><a href="http://www.devalot.com/articles/2011/11/objc-object-model.html">http://www.devalot.com/articles/2011/11/objc-object-model.html</a></p></li>
<li><p><a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html">http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html</a></p></li>
<li><p><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html</a></p></li>
<li><p><a href="http://wwwmain.gnustep.org/resources/downloads.php">gunstep的实现源码</a></p></li>
<li><p><a href="http://algorithm.com.au/downloads/talks/objective-c-internals/objective-c-internals.pdf">http://algorithm.com.au/downloads/talks/objective-c-internals/objective-c-internals.pdf</a></p></li>
<li><p><a href="http://opensource.apple.com/source/objc4/objc4-532/runtime/">http://opensource.apple.com/source/objc4/objc4-532/runtime/</a></p></li>
<li><p><a href="https://github.com/AFNetworking/AFNetworking">https://github.com/AFNetworking/AFNetworking</a></p></li>
<li><p><a href="https://github.com/jverkoey/nimbus">https://github.com/jverkoey/nimbus</a></p></li>
<li><p><a href="https://github.com/mmin18/WaxPatch">https://github.com/mmin18/WaxPatch</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 GCD]]></title>
    <link href="http://orinchen.github.io/blog/2014/03/15/use-gcd/"/>
    <updated>2014-03-15T10:35:36+08:00</updated>
    <id>http://orinchen.github.io/blog/2014/03/15/use-gcd</id>
    <content type="html"><![CDATA[<p>本文转载自:<a href="http://blog.devtang.com/blog/2012/02/22/use-gcd/">唐巧的技术博客</a></p>

<h2>什么是GCD</h2>

<p>Grand Central Dispatch (GCD)是 Apple 开发的一个多核编程的解决方法。该方法在 Mac OS X 10.6 雪豹中首次推出，并随后被引入到了 iOS4.0 中。GCD 是一个替代诸如 NSThread, NSOperationQueue, NSInvocationOperation 等技术的很高效和强大的技术，它看起来象就其它语言的闭包(Closure)一样，但苹果把它叫做 blocks。</p>

<!--more-->


<h2>应用举例</h2>

<p>让我们来看一个编程场景。我们要在 iPhone 上做一个下载网页的功能，该功能非常简单，就是在 iPhone 上放置一个按钮，点击该按钮时，显示一个转动的圆圈，表示正在进行下载，下载完成之后，将内容加载到界面上的一个文本控件中。</p>

<h2>不用GCD前</h2>

<p>虽然功能简单，但是我们必须把下载过程放到后台线程中，否则会阻塞UI线程显示。所以，如果不用 GCD, 我们需要写如下3个方法：</p>

<ul>
<li>someClick 方法是点击按钮后的代码，可以看到我们用 NSInvocationOperation 建了一个后台线程，并且放到 NSOperationQueue 中。后台线程执行 download 方法。</li>
<li>download 方法处理下载网页的逻辑。下载完成后用 performSelectorOnMainThread 执行download_completed 方法。</li>
<li>download_completed 进行 clear up 的工作，并把下载的内容显示到文本控件中。</li>
</ul>


<p>这3个方法的代码如下。可以看到，虽然 开始下载 –> 下载中 –> 下载完成 这3个步骤是整个功能的三步。但是它们却被切分成了3块。他们之间因为是3个方法，所以还需要传递数据参数。如果是复杂的应用，数据参数很可能就不象本例子中的 NSString 那么简单了，另外，下载可能放到 Model 的类中来做，而界面的控制放到 View Controller 层来做，这使得本来就分开的代码变得更加散落。代码的可读性大大降低。</p>

<pre><code class="objc">static NSOperationQueue * queue;

- (IBAction)someClick:(id)sender {
    self.indicator.hidden = NO;
    [self.indicator startAnimating];
    queue = [[NSOperationQueue alloc] init];
    NSInvocationOperation * op = [[[NSInvocationOperation alloc] initWithTarget:self selector:@selector(download) object:nil] autorelease];
    [queue addOperation:op];
}

- (void)download {
    NSURL * url = [NSURL URLWithString:@"http://www.youdao.com"];
    NSError * error;
    NSString * data = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error];
    if (data != nil) {
        [self performSelectorOnMainThread:@selector(download_completed:) withObject:data waitUntilDone:NO];
    } else {
        NSLog(@"error when download:%@", error);
        [queue release];
    }
}

- (void) download_completed:(NSString *) data {
    NSLog(@"call back");
    [self.indicator stopAnimating];
    self.indicator.hidden = YES;
    self.content.text = data;
    [queue release];
}
</code></pre>

<h2>使用GCD后</h2>

<p>如果使用 GCD，以上3个方法都可以放到一起，如下所示：</p>

<pre><code class="objc">// 原代码块一
self.indicator.hidden = NO;
[self.indicator startAnimating];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    // 原代码块二
    NSURL * url = [NSURL URLWithString:@"http://www.youdao.com"];
    NSError * error;
    NSString * data = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error];
    if (data != nil) {
        // 原代码块三
        dispatch_async(dispatch_get_main_queue(), ^{
            [self.indicator stopAnimating];
            self.indicator.hidden = YES;
            self.content.text = data;
        });
    } else {
        NSLog(@"error when download:%@", error);
    }
});
</code></pre>

<p>首先我们可以看到，代码变短了。因为少了原来3个方法的定义，也少了相互之间需要传递的变量的封装。</p>

<p>另外，代码变清楚了，虽然是异步的代码，但是它们被 GCD 合理的整合在一起，逻辑非常清晰。如果应用上 MVC 模式，我们也可以将 View Controller 层的回调函数用 GCD 的方式传递给 Modal 层，这相比以前用 @selector 的方式，代码的逻辑关系会更加清楚。</p>

<h2>GCD的定义</h2>

<p>简单 GCD 的定义有点象函数指针，差别是用 ^ 替代了函数指针的 * 号，如下所示：</p>

<pre><code class="objc">// 申明变量
 (void) (^loggerBlock)(void);
 // 定义

 loggerBlock = ^{
      NSLog(@"Hello world");
 };
 // 调用
 loggerBlock();
</code></pre>

<p>但是大多数时候，我们通常使用内联的方式来定义它，即将它的程序块写在调用的函数里面，例如这样：</p>

<pre><code class="objc">dispatch_async(dispatch_get_global_queue(0, 0), ^{
      // something
 });
</code></pre>

<p>从上面大家可以看出，block 有如下特点：</p>

<ol>
<li>程序块可以在代码中以内联的方式来定义。</li>
<li>程序块可以访问在创建它的范围内的可用的变量。</li>
</ol>


<h2>系统提供的 dispatch 方法</h2>

<p>为了方便地使用 GCD，苹果提供了一些方法方便我们将 block 放在主线程或后台线程执行，或者延后执行。使用的例子如下：</p>

<pre><code class="objc">//  后台执行：
 dispatch_async(dispatch_get_global_queue(0, 0), ^{
      // something
 });
 // 主线程执行：
 dispatch_async(dispatch_get_main_queue(), ^{
      // something
 });
 // 一次性执行：
 static dispatch_once_t onceToken;
 dispatch_once(&amp;onceToken, ^{
     // code to be executed once
 });
 // 延迟2秒执行：
 double delayInSeconds = 2.0;
 dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC);
 dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
     // code to be executed on the main queue after delay
 });
</code></pre>

<p>dispatch_queue_t 也可以自己定义，如要要自定义 queue，可以用 dispatch_queue_create 方法，示例如下：</p>

<pre><code class="objc">dispatch_queue_t urls_queue = dispatch_queue_create("blog.devtang.com", NULL);
dispatch_async(urls_queue, ^{
     // your code
});
dispatch_release(urls_queue);
</code></pre>

<p>另外，GCD 还有一些高级用法，例如让后台2个线程并行执行，然后等2个线程都结束后，再汇总执行结果。这个可以用 dispatch_group, dispatch_group_async 和 dispatch_group_notify 来实现，示例如下：</p>

<pre><code class="objc">dispatch_group_t group = dispatch_group_create();
 dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{
      // 并行执行的线程一
 });
 dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{
      // 并行执行的线程二
 });
 dispatch_group_notify(group, dispatch_get_global_queue(0,0), ^{
      // 汇总结果
 });
</code></pre>

<h2>修改block之外的变量</h2>

<p>默认情况下，在程序块中访问的外部变量是复制过去的，即写操作不对原变量生效。但是你可以加上 __block 来让其写操作生效，示例代码如下：</p>

<pre><code class="objc">__block int a = 0;
 void  (^foo)(void) = ^{
      a = 1;
 }
 foo();
 // 这里，a的值被修改为1
</code></pre>

<h2>后台运行</h2>

<p>使用 block 的另一个用处是可以让程序在后台较长久的运行。在以前，当 app 被按 home 键退出后，app 仅有最多5秒钟的时候做一些保存或清理资源的工作。但是应用可以调用UIApplication 的 beginBackgroundTaskWithExpirationHandler 方法，让app最多有 10 分钟的时间在后台长久运行。这个时间可以用来做清理本地缓存，发送统计数据等工作。</p>

<p>让程序在后台长久运行的示例代码如下：</p>

<pre><code class="objc">// AppDelegate.h文件
@property (assign, nonatomic) UIBackgroundTaskIdentifier backgroundUpdateTask;

// AppDelegate.m文件
- (void)applicationDidEnterBackground:(UIApplication *)application
{
    [self beingBackgroundUpdateTask];
    // 在这里加上你需要长久运行的代码
    [self endBackgroundUpdateTask];
}

- (void)beingBackgroundUpdateTask
{
    self.backgroundUpdateTask = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^{
        [self endBackgroundUpdateTask];
    }];
}

- (void)endBackgroundUpdateTask
{
    [[UIApplication sharedApplication] endBackgroundTask: self.backgroundUpdateTask];
    self.backgroundUpdateTask = UIBackgroundTaskInvalid;
}
</code></pre>

<h2>总结</h2>

<p>总体来说，GCD 能够极大地方便开发者进行多线程编程。大家应该尽量使用 GCD 来处理后台线程和 UI 线程的交互。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转字符串]]></title>
    <link href="http://orinchen.github.io/blog/2014/03/07/working-with-strings/"/>
    <updated>2014-03-07T23:32:36+08:00</updated>
    <id>http://orinchen.github.io/blog/2014/03/07/working-with-strings</id>
    <content type="html"><![CDATA[<p>在每个应用里我们都大量使用字符串。下面我们将快速看看一些常见的操作字符串的方法，过一遍常见操作的最佳实践。</p>

<!--more-->


<h2>字符串的比较、搜索和排序</h2>

<p>排序和比较字符串比第一眼看上去要复杂得多。不只是因为字符串可以包含 <strong>代理对（surrogate pairs）</strong> (详见 <a href="http://www.objc.io/issue-9/unicode.html#peculiar-unicode-features">Ole 写的这篇关于 Unicode 的文章</a>) ，而且比较还与字符串的本地化相关。在某些极端情况下相当棘手。</p>

<p>苹果文档中 <strong><em>String Programming Guide</em></strong> 里有一节叫做<strong>“字符与字形集群（Characters and Grapheme Clusters）”</strong>，里面提到一些陷阱。例如对于排序来说，一些欧洲语言将序列“ch”当作单个字母。在一些语言里，“ä”被认为等同于“a”，而在其它语言里它却被排在“z”后面。</p>

<p>而 <code>NSString</code> 有一些方法来帮助我们处理这种复杂性。首先看下面的方法：</p>

<pre><code class="objc">- (NSComparisonResult)compare:(NSString *)aString 
                      options:(NSStringCompareOptions)mask 
                        range:(NSRange)range 
                       locale:(id)locale
</code></pre>

<p>它带给我们充分的灵活性。另外，还有很多“便捷函数”都使用了这个方法。
与比较有关的可用参数如下：</p>

<pre><code class="objc">NSCaseInsensitiveSearch
NSLiteralSearch
NSNumericSearch
NSDiacriticInsensitiveSearch
NSWidthInsensitiveSearch
NSForcedOrderingSearch
</code></pre>

<p>它们都可以用逻辑或运算组合在一起。</p>

<ul>
<li><p><code>NSCaseInsensitiveSearch</code>：“A”等同于“a”，然而在某些地方还有更复杂的情况。例如，在德国，“ß” 和“SS”是等价的。</p></li>
<li><p><code>NSLiteralSearch</code>：Unicode 的点对 Unicode 点比较。它只在所有字符都用相同的方式组成的情况下才会返回相等。LATIN CAPITAL LETTER A 加上 COMBINING RING ABOVE 并不等同于 LATIN CAPITAL LETTER A WITH RING ABOVE.</p></li>
</ul>


<blockquote><p>译注：这个要解释一下，首先，每一个Unicode都是有官方名字的！LATIN CAPITAL  LETTER A是一个大写“A”，COMBINING RING ABOVE是一个  ̊，LATIN CAPITAL LETTER A WITH RING ABOVE，这是Å前两者的组合不等同于后者。</p>

<p>Clients that use persistent connections SHOULD limit the number of simultaneous connections that they maintain to a given server. A single-user client SHOULD NOT maintain more than 2 connections with any server or proxy. A proxy SHOULD use up to 2*N connections to another server or proxy, where N is the number of simultaneously active users. These guidelines are intended to improve HTTP response times and avoid congestion.</p></blockquote>

<p> <blockquote><p>Clients that use persistent connections SHOULD limit the number of simultaneous connections that they maintain to a given server. A single-user client SHOULD NOT maintain more than 2 connections with any server or proxy. A proxy SHOULD use up to 2*N connections to another server or proxy, where N is the number of simultaneously active users. These guidelines are intended to improve HTTP response times and avoid congestion.</p><footer><strong><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.1.4</strong> <cite>&#8220;>http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.1.4</cite></footer></blockquote></p>

<ul>
<li><p><code>NSNumericSearch</code>：它对字符串里的数字排序，所以 “Section 9” &lt; “Section 20” &lt; “Section 100.”</p></li>
<li><p><code>NSDiacriticInsensitiveSearch</code> : “A”等同于“Å”等同于“Ä.”</p></li>
<li><p><code>NSWidthInsensitiveSearch</code> : 一些东亚文字（平假名 和 片假名）有全宽与半宽两种形式。
很值得一提的是 <code>- (NSComparisonResult)localizedStandardCompare:</code>，它排序的方式和 Finder 一样。它对应的选项是 <code>NSCaseInsensitiveSearch</code>、<code>NSNumericSearch</code>、 <code>NSWidthInsensitiveSearch</code> 以及 <code>NSForcedOrderingSearch</code> 。如果我们要在UI上显示一个文件列表，用它就最合适不过了。</p></li>
</ul>


<p>大小写不敏感的比较和音调符号不敏感的比较都是相对复杂和昂贵的操作。如果我们需要比较很多次字符串那这就会成为一个性能上的瓶颈（例如对一个大的数据集进行排序），一个常见的解决方法是同时存储原始字符串和折叠字符串。例如，我们的 <code>Contact</code>  类有一个正常的 <code>name</code>  属性，在内部它还有一个 <code>foldedName</code>  属性，它将自动在 <code>name</code> 变化时更新。那么我们就可以使用 <code>NSLiteralSearch</code>  来比较 <code>name</code> 的折叠版本。<code>NSString</code> 有一个方法来创建折叠版本：</p>

<pre><code class="objc">- (NSString *)stringByFoldingWithOptions:(NSStringCompareOptions)options 
                                  locale:(NSLocale *)locale
</code></pre>

<h2>搜索</h2>

<p>要在一个字符串中搜索子字符串，最灵活性的方法是:</p>

<pre><code class="objc">- (NSRange)rangeOfString:(NSString *)aString 
                 options:(NSStringCompareOptions)mask 
                   range:(NSRange)searchRange 
                  locale:(NSLocale *)locale
</code></pre>

<p>同时，还有一些“便捷方法”，它们在最终都会调用上面这个方法，我们可以传入上面列出的参数，以及以下这些额外的参数：</p>

<pre><code class="objc">NSBackwardsSearch
NSAnchoredSearch
NSRegularExpressionSearch
</code></pre>

<ul>
<li><p><code>NSBackwardsSearch</code>：在字符串的末尾开始反向搜索。</p></li>
<li><p><code>NSAnchoredSearch</code>： 只考虑搜索的起始点（单独使用）或终止点（当与  <code>NSBackwardsSearch</code> 结合使用时）。这个方法可以用来检查前缀或者后缀，以及 <em>大小写不敏感（case-insensitive）</em>或者 <em>音调不敏感（diacritic-insensitive）</em>的比较。</p></li>
<li><p><code>NSRegularExpressionSearch</code>：使用正则表达式搜索，要了解更多与使用正则表达式有关的信息，请关注 Chris’s 的 String Parsing 。</p></li>
</ul>


<p>另外，还有一个方法：</p>

<pre><code class="objc">- (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)aSet 
                           options:(NSStringCompareOptions)mask 
                             range:(NSRange)aRange
</code></pre>

<p>与前面搜索字符串不同的是， 它只搜索给定字符集的第一个字符。即使只搜索一个字符，但如果由于此字符是由元字符组成的序列（composed character sequence），所以返回范围的长度也可能大于1。</p>

<h2>大写与小写</h2>

<p>一定不要使用 <code>NSString</code> 的 <code>-uppercaseString</code>  或者 <code>-lowercaseString</code> 的方法来处理 UI 显示的字符串，而应该使用 <code>-uppercaseStringWithLocale</code> 来代替， 比如：</p>

<pre><code class="objc">NSString *name = @"Tómas"; 
cell.text = [name uppercaseStringWithLocale:[NSLocale currentLocale]];
</code></pre>

<h2>格式化字符串</h2>

<p>同 <strong>C</strong> 语言中的 <code>sprintf</code> 函数( ANSI C89 中的一个函数 )类似, <strong>Objective-C</strong> 中的 <code>NSString</code> 类也有如下的3个方法:</p>

<pre><code class="objc">-initWithFormat:
-initWithFormat:arguments:
+stringWithFormat:
</code></pre>

<p>需要注意这些格式化方法都是 <strong><em>非本地化</em></strong> 的 。所以这些方法得到的字符串是不能直接拿来显示在用户界面上的。如果需要本地化，那我们需要使用下面这些方法:</p>

<pre><code class="objc">-initWithFormat:locale:
-initWithFormat:locale:arguments:
+localizedStringWithFormat:
</code></pre>

<p>Florian 有一篇关于<a href="http://www.objc.io/issue-9/string-localization.html#localized-format-strings">字符串的本地化</a>的文章更详细地讨论了这个问题。</p>

<p><a href="http://linux.die.net/man/3/printf">printf(3)</a>的man页面有关于它如何格式化字符串的全部细节。除了所谓的转换格式（它以％字符开始），格式化字符串会被逐字复制：</p>

<pre><code class="objc">double a = 25812.8074434;
float b = 376.730313461;
NSString *s = [NSString stringWithFormat:@"%g :: %g", a, b];
// "25812.8 :: 376.73"
</code></pre>

<p>我们格式化了两个浮点数。注意单精度浮点数和双精度浮点数能同一个转换格式。</p>

<h2>对象</h2>

<p>除了来自 <a href="http://linux.die.net/man/3/printf">printf(3)</a> 的转换规范，我们还可以使用 <code>%@</code> 来输出一个对象。在对象描述那一节中有述，如果对象响应 <code>-descriptionWithLocale:</code> 方法，则调用它，否则调用 <code>-description</code>。<code>%@</code> 被结果替换。</p>

<h2>整数</h2>

<p>使用整形数字时，有些需要注意的细节。首先，有符号数（d和i）和无符号数（o、u、x和X）分别有转换规范。需要使用者选择具体的类型。
如果我们使用的东西是 <code>printf</code> 不知道的，我们必须要做类型转换。<code>NSUInteger</code> 正是这样一个例子，它在64位和32位平台上是不一样的。下面的例子可以同时工作在32位和64位平台。</p>

<pre><code class="objc">uint64_t p = 2305843009213693951;
NSString *s = [NSString stringWithFormat:@"The ninth Mersenne prime is %llu", (unsigned long long) p];
// "The ninth Mersenne prime is 2305843009213693951"
</code></pre>

<table>
<thead>
<tr>
<th style="text-align:center;">    Modifier   </th>
<th style="text-align:center;">      d, i      </th>
<th style="text-align:center;">     o, u, x, X        </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">  hh           </td>
<td style="text-align:center;">  signed char   </td>
<td style="text-align:center;">  unsigned char        </td>
</tr>
<tr>
<td style="text-align:center;">  h            </td>
<td style="text-align:center;">  short         </td>
<td style="text-align:center;">  unsigned short       </td>
</tr>
<tr>
<td style="text-align:center;">  (none)       </td>
<td style="text-align:center;">  int           </td>
<td style="text-align:center;">  unsigned int         </td>
</tr>
<tr>
<td style="text-align:center;">  l (ell)      </td>
<td style="text-align:center;">  long          </td>
<td style="text-align:center;">  unsigned long        </td>
</tr>
<tr>
<td style="text-align:center;">  ll (ell ell) </td>
<td style="text-align:center;">  long long     </td>
<td style="text-align:center;">  unsigned long long   </td>
</tr>
<tr>
<td style="text-align:center;">  j            </td>
<td style="text-align:center;">  intmax_t      </td>
<td style="text-align:center;">  uintmax_t            </td>
</tr>
<tr>
<td style="text-align:center;">  t            </td>
<td style="text-align:center;">  ptrdiff_t     </td>
<td style="text-align:center;">                       </td>
</tr>
<tr>
<td style="text-align:center;">  z            </td>
<td style="text-align:center;">                </td>
<td style="text-align:center;">  size_t               </td>
</tr>
</tbody>
</table>


<p>适用于整数的转换规则有：</p>

<pre><code class="objc">int m = -150004021;
uint n = 150004021U;
NSString *s = [NSString stringWithFormat:@"d:%d i:%i o:%o u:%u x:%x X:%X", m, m, n, n, n, n];
// "d:-150004021 i:-150004021 o:1074160465 u:150004021 x:8f0e135 X:8F0E135"
</code></pre>

<p><code>%d</code> 和 <code>%i</code> 具有一样的功能，它们都打印出有符号十进制数。<code>%o</code> 就较为晦涩了：它使用八进制表示。<code>%u</code> 输出无符号十进制数——它是我们常用的。最后 <code>%x</code> 和 <code>%X</code> 使用十六进制表示——后者使用大写字母。</p>

<p>对于 <code>x%</code> 和 <code>X%</code>，我们可以在 0x 前面添加 “#” 井字符前缀看，增加可读性。
我们可以传入特定参数，来设置最小字段宽度和最小数字位数（默认两者都是0），以及左/右对齐。请查看man页面获取详细信息。下面是一些例子：</p>

<pre><code class="objc">int m = 42;
NSString *s = [NSString stringWithFormat:@"'%4d' '%-4d' '%+4d' '%4.3d' '%04d'", m, m, m, m, m];
// ‘42’ ‘42 ’ ‘ +42’ ‘ 042’ ‘0042’
m = -42;
NSString *s = [NSString stringWithFormat:@"'%4d' '%-4d' '%+4d' '%4.3d' '%04d'", m, m, m, m, m];
// ‘ -42’ ‘-42 ’ ‘ -42’ ‘-042’ ‘-042’
</code></pre>

<p>%p  可用于打印出指针——它和 %#x  相似但可同时在32位和64位平台上正常工作。</p>

<h2>浮点数</h2>

<p>关于浮点数的转换规则有8个：eEfFgGaA。但除了 <code>%f</code> 和 <code>%g</code> 外我们很少使用其它的。对于指数部分，小写的版本使用小写 e，大写的版本就使用大写 E。
通常 <code>%g</code>  是浮点数的全能转换符 ，它与 <code>%f</code>  的不同在下面的例子里显示得很清楚：</p>

<pre><code class="objc">double v[5] = {12345, 12, 0.12, 0.12345678901234, 0.0000012345678901234};
NSString *s = [NSString stringWithFormat:@"%g %g %g %g %g", v[0], v[1], v[2], v[3], v[4]];
// "12345 12 0.12 0.123457 1.23457e-06"
NSString *s = [NSString stringWithFormat:@"%f %f %f %f %f", v[0], v[1], v[2], v[3], v[4]];
// "12345.000000 12.000000 0.120000 0.123457 0.000001"
</code></pre>

<p>和整数一样，我们依然可以指定最小字段宽度和最小数字数。</p>

<h2>指定位置</h2>

<p>格式化字符串允许使用参数来改变顺序：</p>

<pre><code class="objc">[NSString stringWithFormat:@"%2$@ %1$@", @"1st", @"2nd"];
// "2nd 1st"
</code></pre>

<p>我们只需将从1开始的参数与一个$接在%后面。这种写法在进行本地化的时候极其常见，因为在不同语言中，各个参数所处的顺序位置可能不尽相同。</p>

<h2>NSLog()</h2>

<p><code>NSLog()</code> 函数与 <code>+stringWithFormat:</code> 的工作方式一样。我们可以调用：</p>

<pre><code class="objc">int magic = 42;
NSLog(@"The answer is %d", magic);
</code></pre>

<p>下面的代码可以用同样的方式构造字符串：</p>

<pre><code class="objc">int magic = 42;
NSString *output = [NSString stringWithFormat:@"The answer is %d", magic];
</code></pre>

<p>显然 <code>NSLog()</code> 会输出字符串，并且它会加上时间戳、进程名、进程ID以及线程ID作为前缀。</p>

<h2>实现能接受格式化字符串的方法</h2>

<p>有时在我们自己的类中提供一个能接受格式化字符串的方法会很方便使用。假设我们要实现的是一个 To Do 应用，它包含一个 <code>Item</code> 类。我们想要提供：</p>

<pre><code class="objc">+ (instancetype)itemWithTitleFormat:(NSString *)format, ...
</code></pre>

<p>如此我们就可以使用：</p>

<pre><code class="objc">Item *item = [Item itemWithFormat:@"Need to buy %@ for %@", food, pet];
</code></pre>

<p>这种类型的方法可以接受可变数量的参数，所以被称为可变参数方法。我们必须使用一个定义在 <code>stdarg.h</code> 里的宏来使用可变参数。上面方法的实现代码可能会像下面这样：</p>

<pre><code class="objc">+ (instancetype)itemWithTitleFormat:(NSString *)format, ...;
{
    va_list ap;
    va_start(ap, format);
    NSString *title = [[NSString alloc] initWithFormat:format locale:[NSLocale currentLocale] arguments:ap];
    va_end(ap);
    return [self itemWithTitle:title];
}
</code></pre>

<p>进一步，我们要添加 <code>NS_FORMAT_FUNCTION</code> 到方法的定义里（在头文件中），如下所示：</p>

<pre><code class="objc">+ (instancetype)itemWithTitleFormat:(NSString *)format, ... NS_FORMAT_FUNCTION(1,2);
</code></pre>

<p><code>NS_FORMAT_FUNCTION</code> 展开为一个方法 <code>__attribute__</code>，它会告诉编译器在索引 1 处的参数是一个格式化字符串，而实际参数从索引2开始。这将允许编译器检查格式化字符串而且会像 <code>NSLog()</code> 和 <code>-[NSString stringWithFormat:]</code> 一样输出警告信息。</p>

<h2>字符与字符串组件</h2>

<p>如有一个字符串“bird”，找出组成它的独立字母是很简单的。第二个字母是“i”（Unicode: LATIN SMALL LETTER I）。而对于像Åse这样的字符串就没那么简单了。看起来像三个字母的组合可有多种方式，例如：</p>

<pre><code>A LATIN CAPITAL LETTER A
̊ COMBINING RING ABOVE
s LATIN SMALL LETTER S
e LATIN SMALL LETTER E
</code></pre>

<p>或者</p>

<pre><code>Å LATIN CAPITAL LETTER A WITH RING ABOVE
s LATIN SMALL LETTER S
e LATIN SMALL LETTER E
</code></pre>

<p>从 <a href="http://www.objc.io/issue-9/unicode.html#peculiar-unicode-features">Ole 写的这篇关于 Unicode 的文章</a> 里可以读到更多关于联合标记（<strong>combining marks</strong>）的信息，其他语言文字有更多复杂的代理对（<strong>complicated surrogate pairs</strong>）。</p>

<p>如果我们要在字符层面处理一个字符串，那我们就要小心翼翼。苹果官方文档中 <strong>String Programming Guide</strong> 有一节叫做 “<strong>Characters and Grapheme Clusters</strong>”，里面有更多关于这一点的细节。</p>

<p><code>NSString</code> 有两个方法：</p>

<pre><code class="objc">-rangeOfComposedCharacterSequencesForRange:
-rangeOfComposedCharacterSequenceAtIndex:
</code></pre>

<p>上面这两个方法在有的时候很有帮助，例如，分开一个字符串时保证我们不会分开被称为代理对（<strong>surrogate pairs</strong>）的东西。</p>

<p>如果我们要在字符串的字符上做工作，<code>NSString</code> 有个叫做 <code>-enumerateSubstringsInRange:options:usingBlock:</code> 的方法。
将 <code>NSStringEnumerationByComposedCharacterSequences</code> 作为选项传递，我们就能扫描所有的字符。例如，用下面的方法，我们可将字符串 “International Business Machines” 变成 “IBM”。</p>

<pre><code class="objc">- (NSString *)initials;
{
    NSMutableString *result = [NSMutableString string];
    [self enumerateSubstringsInRange:NSMakeRange(0, self.length) 
                             options:NSStringEnumerationByWords | NSStringEnumerationLocalized 
                          usingBlock:^(NSString *word, NSRange wordRange, NSRange enclosingWordRange, BOOL *stop1) {
        __block NSString *firstLetter = nil;
        [self enumerateSubstringsInRange:NSMakeRange(0, word.length) 
                                 options:NSStringEnumerationByComposedCharacterSequences 
                              usingBlock:^(NSString *letter, NSRange letterRange, NSRange enclosingLetterRange, BOOL *stop2) {
            firstLetter = letter;
            *stop2 = YES;
        }];
        if (letter != nil) {
            [result appendString:letter];
        };
    }];
    return result;
}
</code></pre>

<p>如文档所示，词和句的分界可能基于地区的变化而变化。因此有 <code>NSStringEnumerationLocalized</code> 选项。</p>

<h2>多行文字字面量</h2>

<p>编译器的确有一个隐蔽的特性：把空格分隔开的字符串衔接到一起。这是什么意思呢？下面两段代码是完全等价的：</p>

<pre><code class="objc">NSString *limerick = @"A lively young damsel named Menzies\n"
@"Inquired: «Do you know what this thenzies?»\n"
@"Her aunt, with a gasp,\n"
@"Replied: "It's a wasp,\n"
@"And you're holding the end where the stenzies.\n";
</code></pre>

<p>和</p>

<pre><code class="objc">NSString *limerick = @"A lively young damsel named Menzies\nInquired: «Do you know what this thenzies?»\nHer aunt, with a gasp,\nReplied: "It's a wasp,\nAnd you're holding the end where the stenzies.\n";
</code></pre>

<p>前者看起来更舒服，但是有一点要注意千万不要在任意一行末尾加入逗号或者分号。
同时也可以这样做：</p>

<pre><code class="objc">NSString * string = @"The man " @"who knows everything " @"learns nothing" @".";
</code></pre>

<blockquote><p>*译者注：上面这行代码原文是有误的，原文是</p>

<pre><code class="objc">NSString *@"The man " @"who knows everything " @"learns nothing" @".";
</code></pre>

<p>读者可以尝试一下，如果这样写是无法通过编译的;</p></blockquote>

<p>编译器只是为我们提供了一个便捷的方式，将多个字符串在编译期组合在了一起。</p>

<h2>可变字符串</h2>

<p>可变字符串有两个常见的使用场景：</p>

<blockquote><ol>
<li>拼接字符串</li>
<li>替换部分字符串</li>
</ol>
</blockquote>

<h3>创建字符串</h3>

<p>可变字符串可以很轻易地把多个字符串在你需要的时候组合起来。</p>

<pre><code class="objc">- (NSString *)magicToken
{
    NSMutableString *string = [NSMutableString string];
    if (usePrefix) {
        [string appendString:@"&gt;&gt;&gt;"];
    }
    [string appendFormat:@"%d--%d", self.foo, self.bar];
    if (useSuffix) {
        [string appendString:@"&gt;&gt;&gt;"];
    }
    return string;
}
</code></pre>

<p>这里要注意的是，虽然原本返回值应该是一个 <code>NSString</code> 类型的对象，我们只是简单地返回一个 <code>NSMutableString</code> 类型的对象。</p>

<h3>替换字符串</h3>

<p>可变字符串除了追加组合之外，还提供了以下4个方法：</p>

<pre><code class="objc">-deleteCharactersInRange:
-insertString:atIndex:
-replaceCharactersInRange:withString:
-replaceOccurrencesOfString:withString:options:range:
</code></pre>

<p>这些方法和 <code>NSString</code> 的类似：</p>

<pre><code class="objc">-stringByReplacingOccurrencesOfString:withString:
-stringByReplacingOccurrencesOfString:withString:options:range:
-stringByReplacingCharactersInRange:withString:
</code></pre>

<p>但是它没有创建新的字符串仅仅把当前字符串变成了一个可变的类型，这样让代码更容易阅读，以及提升些许性能。</p>

<pre><code class="objc">NSMutableString *string; // 假设我们已经有了一个名为 string 的字符串
// 现在要去掉它的一个前缀，做法如下:
NSString *prefix = @"WeDon’tWantThisPrefix"
NSRange r = [string rangeOfString:prefix 
                          options:NSAnchoredSearch 
                            range:NSMakeRange(0, string.length) 
                           locale:nil];
if (r.location != NSNotFound) {
    [string deleteCharactersInRange:r];
}
</code></pre>

<h2>连接组件</h2>

<p>一个看似微不足道但很常见的情况是字符串连接。比如现在有这样几个字符串：</p>

<pre><code>Hildr
Heidrun
Gerd
Guðrún
Freya
Nanna
Siv
Skaði
Gróa
</code></pre>

<p>我们想用它们来创建下面这样的一个字符串：</p>

<pre><code>Hildr, Heidrun, Gerd, Guðrún, Freya, Nanna, Siv, Skaði, Gróa
</code></pre>

<p>那么就可以这样做：</p>

<pre><code>NSArray *names = @["Hildr", @"Heidrun", @"Gerd", @"Guðrún", @"Freya", @"Nanna", @"Siv", @"Skaði", @"Gróa"];
NSString *result = [names componentsJoinedByString:@", "];
</code></pre>

<p>如果我们将其显示给用户，我们就要使用本地化表达，确保将最后一部分替换相应语言的 “, and” ：</p>

<pre><code class="objc">@implementation NSArray (ObjcIO_GroupedComponents)

- (NSString *)groupedComponentsWithLocale:(NSLocale *)locale;
{
    if (self.count &lt; 1) {
        return @"";
    } else if (self.count &lt; 2) {
        return self[0];
    } else if (self.count &lt; 3) {
        NSString *joiner = NSLocalizedString(@"joiner.2components", @"");
        return [NSString stringWithFormat:@"%@%@%@", self[0], joiner, self[1]];
    } else {
        NSString *joiner = [NSString stringWithFormat:@"%@ ", [locale objectForKey:NSLocaleGroupingSeparator]];
        NSArray *first = [self subarrayWithRange:NSMakeRange(0, self.count - 1)];
        NSMutableString *result = [NSMutableString stringWithString:[first componentsJoinedByString:joiner]];
        NSString *lastJoiner = NSLocalizedString(@"joiner.3components", @"");
        [result appendString:lastJoiner];
        [result appendString:self.lastObject];
        return result;
    }
}
@end
</code></pre>

<p>那么在本地化的时候，如果是英语，应该是：</p>

<pre><code class="objc">"joiner.2components" = " and ";
"joiner.3components" = ", and ";
</code></pre>

<p>如果是德语，则应该是：</p>

<pre><code class="objc">"joiner.2components" = " und ";
"joiner.3components" = " und ";
</code></pre>

<p>结合组件的逆过程可以用 <code>-componentsSeparatedByString:</code>，这个方法会将一个字符串变成一个数组。例如，将 “12|5|3” 变成 “12”、“5” 和 “3”。</p>

<h2>对象描述</h2>

<p>在许多面向对象编程语言里，对象有一个叫做 <code>toString()</code> 或类似的方法。在 <strong>Objective-C</strong> 里，这个方法是：</p>

<pre><code class="objc">- (NSString *)description
</code></pre>

<p>以及它的兄弟方法:</p>

<pre><code class="objc">- (NSString *)debugDescription
</code></pre>

<p>当自定义模型对象时，覆写 <code>-description</code> 方法是一个好习惯，在UI上显示该对象时调用的就是 <code>-description</code> 方法的返回值。假定我们有一个 <code>Contact</code> 类，下面是它的 <code>-description</code> 方法实现。</p>

<pre><code class="objc">- (NSString *)description
{
    return self.name;
}
</code></pre>

<p>我们可以像下面代码这样格式化字符串：</p>

<pre><code class="objc">label.text = [NSString stringWithFormat:NSLocalizedString(@"%@ has been added to the group “%@”.", @""), contact, group];
</code></pre>

<p>因为该字符串是用来做UI显示的，我们可能需要做本地化，那么我们就需要覆写</p>

<pre><code class="objc ">- (NSString *)descriptionWithLocale:(NSLocale *)locale 
</code></pre>

<p>方法。</p>

<p><code>%@</code> 会首先调用 <code>-descriptionWithLocale</code>，如果没有返回值，再调用 <code>-description</code>，在调试时，打印一个对象，我们用 <code>po</code> 这个命令（它是 print object 的缩写）</p>

<pre><code>(lldb) po contact
</code></pre>

<p>如果在调试窗口的终端下输入 <code>po contact</code>，它会调用对象的 <code>-debugDescription</code> 方法。默认情况下 <code>-debugDescription</code> 是直接调用 <code>-description</code>。如果你希望输出不同的信息，那么就分别覆写两个方法。大多数情况下，尤其是对于非数据模型的对象，你只需要覆写 <code>-description</code> 就能满足需求了。</p>

<p>实际上对象的标准格式化输出是这样的：</p>

<pre><code class="objc">- (NSString *)description;
{
    return [NSString stringWithFormat:@"&lt;%@: %p&gt;", self.class, self];
}
</code></pre>

<p><code>NSObject</code> 就是这么干的。当你覆写该方法时，也可以像这样写。假定我们有一个 <code>DetailViewController</code>，在它的UI上要显示一个 <code>contact</code> ，我们可能会这样覆写该方法：</p>

<pre><code class="objc">- (NSString *)description;
{
    return [NSString stringWithFormat:@"&lt;%@: %p&gt; contact = %@", self.class, self, self.contact.debugDescription];
}
</code></pre>

<h2>NSManagedObject 子类的描述</h2>

<p>我们将特别注意向 <code>NSManagedObject</code> 的子类添加 <code>-description</code> / <code>-debugDescription</code> 的情况。由于 <strong>Core Data</strong> 的惰性加载机制（<strong>faulting mechanism</strong>）允许未加载数据的对象存在，所以当我们调用 <code>-debugDescription</code> 我们并不希望改变我们的应用程序的状态，因此我要确保检查 isFault  这个属性。例如，我们可如下这样实现它：</p>

<pre><code class="objc">- (NSString *)debugDescription;
{
    NSMutableString *description = [NSMutableString stringWithFormat:@"&lt;%@: %p&gt;", self.class, self];
    if (! self.isFault) {
        [description appendFormat:@" %@ \"%@\" %gL", self.identifier, self.name, self.metricVolume];
    }
    return description;
}
</code></pre>

<p>再次，因为它们是模型对象，重载 <code>-description</code> 简单地返回描述实例的属性名就可以了。</p>

<h2>文件路径</h2>

<p>简单来说就是我们不应该使用 <code>NSString</code> 来描述文件路径。对于 OS X 10.7 和 iOS 5， <code>NSURL</code> 更便于使用，而且更有效率，它还能缓存文件系统的属性。
再者，<code>NSURL</code> 有八个方法来访问被称为 <strong>resource values</strong> 的东西。它们提供给我们一个稳定的接口来获取和设置文件与目录的多种属性，例如本地化文件名（<code>NSURLLocalizedNameKey</code>）、文件大小（<code>NSURLFileSizeKey</code>），以及创建日期（ <code>NSURLCreationDateKey</code>），等等。
尤其是在遍历目录内容时，使用 <code>-[NSFileManager enumeratorAtURL:includingPropertiesForKeys:options:errorHandler:]</code> 附带一个关键词列表，然后用 <code>-getResourceValue:forKey:error:</code> 检索它们，能带来显著的性能提升。</p>

<p>下面是一个简短的例子展示了如何将它们组合在一起：</p>

<pre><code class="objc">NSError *error = nil;
NSFileManager *fm = [[NSFileManager alloc] init];
NSURL *documents = [fm URLForDirectory:NSDocumentationDirectory 
                              inDomain:NSUserDomainMask 
                     appropriateForURL:nil 
                                create:NO 
                                 error:&amp;error];
NSArray *properties = @[NSURLLocalizedNameKey, NSURLCreationDateKey];
NSDirectoryEnumerator *dirEnumerator = [fm enumeratorAtURL:documents
                                includingPropertiesForKeys:properties
                                                   options:0
                                              errorHandler:nil];
for (NSURL *fileURL in dirEnumerator) {
    NSString *name = nil;
    NSDate *creationDate = nil;
    if ([fileURL getResourceValue:&amp;name 
                           forKey:NSURLLocalizedNameKey 
                            error:NULL] &amp;&amp;
        [fileURL getResourceValue:&amp;creationDate 
                           forKey:NSURLCreationDateKey 
                            error:NULL])
    {
        NSLog(@"'%@' was created at %@", name, creationDate);
    }
}
</code></pre>

<p>我们把属性的键传给  <code>-enumeratorAtURL:</code> 方法中，在遍历目录内容时，这个方法能确保用非常高效的方式获取它们。在循环中，调用 <code>-getResourceValue:</code>… 能简单地从 <code>NSURL</code> 得到已缓存的值，而不用去访问文件系统。</p>

<h2>传递路径到UNIX API</h2>

<p>因为 Unicode 非常复杂，同一个字母有多种表示方式，所以我们需要很小心地传递路径给 UNIX API。在这些情况里，一定不能使用 <code>UTF8String</code>，正确地做法是使用 <code>-fileSystemRepresentation</code> 方法，如下：</p>

<pre><code class="objc">NSURL *documentURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory 
                                                            inDomain:NSUserDomainMask 
                                                   appropriateForURL:nil 
                                                              create:NO 
                                                               error:NULL];
documentURL = [documentURL URLByAppendingPathComponent:name];
int fd = open(documentURL.fileSystemRepresentation, O_RDONLY);
</code></pre>

<p>与 <code>NSURL</code> 类似，同样的情况也发生在 <code>NSString</code> 上。如果我们不这么做，在打开一个文件名或路径名包含合成字符的文件时我们将看到随机错误。在 OS X 上，当用户的短名刚好包含合成字符时就会显得特别糟糕。
我们需要一个 <code>char const *</code> 版本的路径的一些常见情况是 UNIX <code>open()</code> 和 <code>close()</code> 指令。但这也可能发生在 GCD / libdispatch 的 I/O API 上。</p>

<pre><code class="objc">dispatch_io_t
dispatch_io_create_with_path(dispatch_io_type_t type,
        const char *path, int oflag, mode_t mode,
        dispatch_queue_t queue,
        void (^cleanup_handler)(int error));
</code></pre>

<p>如果我们要使用 <code>NSString</code> 来做，那我们要保证像下面这样做：</p>

<pre><code class="objc">NSString *path = ... // 假设我们已经有一个名为 path 的字符串
io = dispatch_io_create_with_path(DISPATCH_IO_STREAM,
    path.fileSystemRepresentation,
    O_RDONLY, 0, queue, cleanupHandler);
</code></pre>

<p><code>-fileSystemRepresentation</code> 所做的是它首先将这个字符串转换成文件系统的规范形式然后用 UTF-8 编码。</p>

<p>原文链接：<a href="http://www.objc.io/issue-9/working-with-strings.html">Working with Strings</a>
翻译：<a href="http://iosinit.com/?author=5"> 朱宏旭</a>，<a href="http://weibo.com/riven0951">riven</a>，<a href="http://weibo.com/u/1709283185?sudaref=iosinit.com">@唯木念</a>
译文链接：<a href="http://iosinit.com/?p=854">objc.io 第9期之玩转字符串</a></p>
]]></content>
  </entry>
  
</feed>
