<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Objective-c | O's World]]></title>
  <link href="http://orinchen.github.io/blog/categories/objective-c/atom.xml" rel="self"/>
  <link href="http://orinchen.github.io/"/>
  <updated>2014-12-23T14:47:02+08:00</updated>
  <id>http://orinchen.github.io/</id>
  <author>
    <name><![CDATA[Orin Chen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何在iOS地图上高效的显示大量数据]]></title>
    <link href="http://orinchen.github.io/blog/2013/12/28/how-to-handle-large-amounts-of-data-on-maps/"/>
    <updated>2013-12-28T16:19:52+08:00</updated>
    <id>http://orinchen.github.io/blog/2013/12/28/how-to-handle-large-amounts-of-data-on-maps</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://www.cocoachina.com/bbs/u.php?action=show&amp;uid=178143">崩月姐姐</a> 翻译自 <a href="http://robots.thoughtbot.com/how-to-handle-large-amounts-of-data-on-maps/">How To Efficiently Display Large Amounts of Data on iOS Maps</a></p>

<p>如何在iOS地图上以用户可以理解并乐于接受的方式来处理和显示大量数据。这个教程将会给大家进行示例说明。</p>

<p>我们要开发一款iOS的app应用，这个应用包含有<em>87000</em>个旅馆的信息，每个旅馆的信息中包括有一个坐标值，一个旅馆名跟一个电话号码。这款app可以在用户拖动、放大缩小地图时更新旅馆数据，而不需要用户重新进行搜索。</p>

<p>为了达到这个目的，我们需要构造一个可快速检索的数据结构。<em>C</em>语言的性能高，所以我们用C语言来构造这个数据结构。为了确保大量的数据不会让用户感到迷惑，所以我们还需要想出一个合并数据的解决方案。最后，为了更好的适应市场，我们需要把app做的更完善一些。</p>

<p>完成这个教学后，你将学到这款app的所有核心内容。</p>

<!--more-->


<p><img src="/images/posts/2013-12-28-how-to-handle-large-amounts-of-data-on-maps/4673_131216112620_1.gif"></p>

<h2>数据结构</h2>

<p>首先我们先来分析下数据，搞清我们要如何处理数据。旅馆数据中包含了一系列的坐标点(包括纬度和经度)，我们需要根据这些坐标点在地图上进行标注。地图可以任意的拖动并放大缩小，所以我们不需要把所有的点都全部绘制出来，我们只需要绘制可以显示在屏幕上的点。核心问题是：我们需要查询出显示在屏幕上的所有的点，所以我们要想出一个查找算法，查找存在于一个矩形范围内的所有点。</p>

<p>一个简单的解决方式就是遍历所有的点，然后判断<em>(xMin&lt;=x&lt;=xMax &amp;&amp; yMin&lt;=y&lt;=yMax)</em>，很不幸，这是一个复杂度为<em>O(N)</em>的算法，显然不适合我们的情况。</p>

<p>这儿有个更好的解决方法，就是我们可以利用对称性来减少我们的查询范围。那么如何能通过查询的每一次的迭代来减少查询的范围呢？我们可以在每个区域内都加索引，这样可以有效减少查询的范围。这种区域索引的方式可以用四叉树来实现，查询复杂度为<em>O(H)</em>(H是查询的那个点所在的树的高度)</p>

<h2>四叉树</h2>

<p>四叉树是一个数据结构，由一系列的结点(node)构成。每个结点包含一个桶(bucket)跟一个包围框(boundingbox)。每个桶里面有一系列的点(point)。如果一个点包含在一个外包围框A中，就会被添加到A所在结点的桶(bucket)中。一旦这个结点的桶满了，这个结点就会分裂成四个子结点，每个子节点的包围框分别是当前结点包围框的1/4。分裂之后那些本来要放到当前结点桶中的点就都会放到子容器的桶中。</p>

<p>那么我们该如何来对四叉树进行编码呢？</p>

<p>我们先来定义基本的结构：</p>

<pre><code class="obj-c">typedef struct TBQuadTreeNodeData { 
    double x; 
    double y; 
    void* data; 
} TBQuadTreeNodeData; 
TBQuadTreeNodeData TBQuadTreeNodeDataMake(double x, double y, void* data); 

typedef struct TBBoundingBox { 
    double x0; double y0; 
    double xf; double yf; 
} TBBoundingBox; 
TBBoundingBox TBBoundingBoxMake(double x0, double y0, double xf, double yf); 

typedef struct quadTreeNode { 
    struct quadTreeNode* northWest; 
    struct quadTreeNode* northEast; 
    struct quadTreeNode* southWest; 
    struct quadTreeNode* southEast; 
    TBBoundingBox boundingBox; 
    int bucketCapacity; 
    TBQuadTreeNodeData *points; 
    int count; 
} TBQuadTreeNode; 
TBQuadTreeNode* TBQuadTreeNodeMake(TBBoundingBox boundary, int bucketCapacity); 
</code></pre>

<p><code>TBQuadTreeNodeData</code>结构包含了坐标点（纬度，经度）。<code>void* data</code>是一个普通的指针，用来存储我们需要的其他信息，如旅馆名跟电话号码。<code>TBBoundingBox</code>代表一个用于范围查询的长方形，也就是之前谈到<em>(xMin&lt;=x&lt;=xMax &amp;&amp; yMin&lt;=y&lt;=yMax)</em>查询的那个长方形。左上角是<em>(xMin,yMin)</em>，右下角是<em>(xMax,yMax)</em>。</p>

<p>最后，我们看下<code>TBQuadTreeNode</code>结构，这个结构包含了四个指针，每个指针分别指向这个结点的四个子节点。它还有一个外包围框和一个数组（数组中就是那个包含一系列坐标点的桶）。</p>

<p>在我们建立完四叉树的同时，空间上的索引也就同时形成了。这是生成四叉树的演示动画。</p>

<p><img src="/images/posts/2013-12-28-how-to-handle-large-amounts-of-data-on-maps/4673_131216113026_1.gif"></p>

<p>下面的代码准确描述了以上动画的过程：</p>

<pre><code class="obj-c">void TBQuadTreeNodeSubdivide(TBQuadTreeNode* node) 
{ 
    TBBoundingBox box = node-&gt;boundingBox; 

    double xMid = (box.xf + box.x0) / 2.0; 
    double yMid = (box.yf + box.y0) / 2.0; 

    TBBoundingBox northWest = TBBoundingBoxMake(box.x0, box.y0, xMid, yMid); 
    node-&gt;northWest = TBQuadTreeNodeMake(northWest, node-&gt;bucketCapacity); 

    TBBoundingBox northEast = TBBoundingBoxMake(xMid, box.y0, box.xf, yMid); 
    node-&gt;northEast = TBQuadTreeNodeMake(northEast, node-&gt;bucketCapacity); 

    TBBoundingBox southWest = TBBoundingBoxMake(box.x0, yMid, xMid, box.yf); 
    node-&gt;southWest = TBQuadTreeNodeMake(southWest, node-&gt;bucketCapacity); 

    TBBoundingBox southEast = TBBoundingBoxMake(xMid, yMid, box.xf, box.yf); 
    node-&gt;southEast = TBQuadTreeNodeMake(southEast, node-&gt;bucketCapacity); 
} 

bool TBQuadTreeNodeInsertData(TBQuadTreeNode* node, TBQuadTreeNodeData data) 
{ 
    // Bail if our coordinate is not in the boundingBox 
    if (!TBBoundingBoxContainsData(node-&gt;boundingBox, data)) { 
        return false; 
    } 

    // Add the coordinate to the points array 
    if (node-&gt;count &lt; node-&gt;bucketCapacity) { 
        node-&gt;points[node-&gt;count++] = data; 
        return true; 
    } 

    // Check to see if the current node is a leaf, if it is, split 
    if (node-&gt;northWest == NULL) { 
        TBQuadTreeNodeSubdivide(node); 
    } 

    // Traverse the tree 
    if (TBQuadTreeNodeInsertData(node-&gt;northWest, data)) return true; 
    if (TBQuadTreeNodeInsertData(node-&gt;northEast, data)) return true; 
    if (TBQuadTreeNodeInsertData(node-&gt;southWest, data)) return true; 
    if (TBQuadTreeNodeInsertData(node-&gt;southEast, data)) return true; 

    return false; 
} 
</code></pre>

<p>现在我们已经完成了四叉树的构造，我们还需要在四叉树上进行区域范围查询并返回<code>TBQuadTreeNodeData</code>结构。以下是区域范围查询的演示动画，在浅蓝区域内的是所有的标注点。当标注点被查询到在指定的区域范围内，则会被标注为绿色。</p>

<p><img src="/images/posts/2013-12-28-how-to-handle-large-amounts-of-data-on-maps/4673_131216180218_1.gif"></p>

<p>以下是查询代码：</p>

<pre><code class="obj-c">typedef void(^TBDataReturnBlock)(TBQuadTreeNodeData data); 

void TBQuadTreeGatherDataInRange(TBQuadTreeNode* node, TBBoundingBox range, TBDataReturnBlock block) 
{ 
    // If range is not contained in the node's boundingBox then bail 
    if (!TBBoundingBoxIntersectsBoundingBox(node-&gt;boundingBox, range)) { 
        return; 
    } 

    for (int i = 0; i &lt; node-&gt;count; i++) { 
        // Gather points contained in range 
        if (TBBoundingBoxContainsData(range, node-&gt;points[i])) { 
            block(node-&gt;points[i]); 
        } 
    } 

    // Bail if node is leaf 
    if (node-&gt;northWest == NULL) { 
        return; 
    } 

    // Otherwise traverse down the tree 
    TBQuadTreeGatherDataInRange(node-&gt;northWest, range, block); 
    TBQuadTreeGatherDataInRange(node-&gt;northEast, range, block); 
    TBQuadTreeGatherDataInRange(node-&gt;southWest, range, block); 
    TBQuadTreeGatherDataInRange(node-&gt;southEast, range, block); 
} 
</code></pre>

<p>用四叉树这种结构可以进行快速的查询。在一个包含成百上千条数据的数据库中，可以以<em>60fps</em>的速度查询上百条数据。</p>

<h2>用旅馆数据来填充四叉树</h2>

<p>旅馆的数据来自于<a href="http://poiplaza.com/">POIplaza</a>这个网站，而且已经格式化成csv文件。我们要从硬盘中读取出数据并对数据进行转换，最后用数据来填充四叉树。</p>

<p>创建四叉树的代码在<code>TBCoordinateQuadTree</code>类中：</p>

<pre><code class="obj-c">typedef struct TBHotelInfo { 
    char* hotelName; 
    char* hotelPhoneNumber; 
} TBHotelInfo; 

TBQuadTreeNodeData TBDataFromLine(NSString *line) 
{ 
    // Example line: 
    // -80.26262, 25.81015, Everglades Motel, USA-United States, +1 305-888-8797 

    NSArray *components = [line componentsSeparatedByString:@","]; 
    double latitude = [components[1] doubleValue]; 
    double longitude = [components[0] doubleValue]; 

    TBHotelInfo* hotelInfo = malloc(sizeof(TBHotelInfo)); 

    NSString *hotelName = [components[2] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]; 
    hotelInfo-&gt;hotelName = malloc(sizeof(char) * hotelName.length + 1); 
    strncpy(hotelInfo-&gt;hotelName, [hotelName UTF8String], hotelName.length + 1); 

    NSString *hotelPhoneNumber = [[components lastObject] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]; 
    hotelInfo-&gt;hotelPhoneNumber = malloc(sizeof(char) * hotelPhoneNumber.length + 1); 
    strncpy(hotelInfo-&gt;hotelPhoneNumber, [hotelPhoneNumber UTF8String], hotelPhoneNumber.length + 1); 

    return TBQuadTreeNodeDataMake(latitude, longitude, hotelInfo); 
} 

- (void)buildTree 
{ 
    NSString *data = [NSString stringWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"USA-HotelMotel" ofType:@"csv"] encoding:NSASCIIStringEncoding error:nil]; 
    NSArray *lines = [data componentsSeparatedByString:@"\n"]; 

    NSInteger count = lines.count - 1; 

    TBQuadTreeNodeData *dataArray = malloc(sizeof(TBQuadTreeNodeData) * count); 
    for (NSInteger i = 0; i &lt; count; i++) { 
        dataArray[i] = TBDataFromLine(lines[i]); 
    } 

    TBBoundingBox world = TBBoundingBoxMake(19, -166, 72, -53); 
    _root = TBQuadTreeBuildWithData(dataArray, count, world, 4); 
} 
</code></pre>

<p>现在我们用iPhone上预加载的数据创建了一个四叉树。接下来我们将处理app的下一个部分：合并数据（clustering）。</p>

<h2>合并数据（clustering）</h2>

<p>现在我们有了一个装满旅馆数据的四叉树，可以用来解决合并数据的问题了。首先，让我们来探索下合并数据的原因。我们合并数据是因为我们不想因为数据过于庞大而使用户迷惑。实际上有很多种方式可以解决这个问题。GoogleMaps根据地图的缩放等级（zoomlevel）来显示搜索结果数据中的一部分数据。地图放的越大，就越能清晰的看到更细节的标注，直到你能看到所有有效的标注。我们将采用这种合并数据的方式，只显示出来旅馆的个数，而不在地图上显示出所有的旅馆信息。</p>

<p>最终呈现的标注是一个中心显示旅馆个数的小圆圈。实现的原理跟如何把图片缩小的原理差不多。我们先在地图上画一个格子。每个格子中包含了很多个小单元格，每个小单元格中的所有旅馆数据合并出一个标注。然后通过每个小单元格中所有旅馆的坐标值的平均值来决定合并后这个标注的坐标值。</p>

<p>这是以上处理的演示动画。</p>

<p><img src="/images/posts/2013-12-28-how-to-handle-large-amounts-of-data-on-maps/4673_131216113354_1.gif"></p>

<p>以下是代码实现过程。在<code>TBCoordinateQuadTree</code>类中添加了一个方法。</p>

<pre><code class="obj-c">- (NSArray *)clusteredAnnotationsWithinMapRect:(MKMapRect)rect withZoomScale:(double)zoomScale 
{ 
    double TBCellSize = TBCellSizeForZoomScale(zoomScale); 
    double scaleFactor = zoomScale / TBCellSize; 

    NSInteger minX = floor(MKMapRectGetMinX(rect) * scaleFactor); 
    NSInteger maxX = floor(MKMapRectGetMaxX(rect) * scaleFactor); 
    NSInteger minY = floor(MKMapRectGetMinY(rect) * scaleFactor); 
    NSInteger maxY = floor(MKMapRectGetMaxY(rect) * scaleFactor); 

    NSMutableArray *clusteredAnnotations = [[NSMutableArray alloc] init]; 

    for (NSInteger x = minX; x &lt;= maxX; x++) { 
        for (NSInteger y = minY; y &lt;= maxY; y++) { 

            MKMapRect mapRect = MKMapRectMake(x / scaleFactor, y / scaleFactor, 1.0 / scaleFactor, 1.0 / scaleFactor); 

            __block double totalX = 0; 
            __block double totalY = 0; 
            __block int count = 0; 

            TBQuadTreeGatherDataInRange(self.root, TBBoundingBoxForMapRect(mapRect), ^(TBQuadTreeNodeData data) { 
                totalX += data.x; 
                totalY += data.y; 
                count++; 
            }); 

            if (count &gt;= 1) { 
                CLLocationCoordinate2D coordinate = CLLocationCoordinate2DMake(totalX / count, totalY / count); 
                TBClusterAnnotation *annotation = [[TBClusterAnnotation alloc] initWithCoordinate:coordinate count:count]; 
                [clusteredAnnotations addObject:annotation]; 
            } 
        } 
    } 

    return [NSArray arrayWithArray:clusteredAnnotations]; 
} 
</code></pre>

<p>上面的方法在指定小单元格大小的前提下合并数据生成了最终的标注。现在我们需要做的就是把这些标注绘制到<em>MKMapView</em>上。首先我们创建一个<em>UIViewController</em>的子类，然后用<em>MKMapView</em>作为它的<em>view</em>视图。在可视区域改变的情况下，我们需要实时更新标注的显示，所以我们要实现<code>mapView:regionDidChangeAnimated:</code>的协议方法。</p>

<pre><code class="obj-c">- (void)mapView:(MKMapView *)mapView regionDidChangeAnimated:(BOOL)animated 
{ 
    [[NSOperationQueue new] addOperationWithBlock:^{ 
        double zoomScale = self.mapView.bounds.size.width / self.mapView.visibleMapRect.size.width; 
        NSArray *annotations = [self.coordinateQuadTree clusteredAnnotationsWithinMapRect:mapView.visibleMapRect withZoomScale:zoomScale]; 

        [self updateMapViewAnnotationsWithAnnotations:annotations]; 
    }]; 
}
</code></pre>

<h1>只添加必要的标注</h1>

<p>在主线程中我们期望尽可能花费较少时间来做运算，这意味着我们要尽可能的把所有内容都放到后台的线程中。为了在主线程中花费更少的时间来做计算，我们只需要绘制一些必要的标注。这可以避免用户滑动过程中感到很卡，从而保证流畅的用户体验。</p>

<p>开始之前，我们看一下下面的图片：</p>

<p><img src="/images/posts/2013-12-28-how-to-handle-large-amounts-of-data-on-maps/4673_131216113807_1.jpg"></p>

<p>左边的屏幕截图是地图进行滑动前的地图快照。这个快照中的标注就是目前mapView中的标注，我们称这个为“before集合”。</p>

<p>右边的屏幕截图是地图进行滑动后的地图快照。这个快照中的标注就是从<code>clusteredAnnotationsWithinMapRect:withZoomScale:</code>这个函数中得到的返回值。我们称这个为“after集合”。</p>

<p>我们期望保留两个快照中都存在的标注点（即重合的那些标注点），去除在“after集合”中不存在的那些标注点，同时添加那些新的标注点。</p>

<pre><code class="obj-c">- (void)updateMapViewAnnotationsWithAnnotations:(NSArray *)annotations 
{ 
    NSMutableSet *before = [NSMutableSet setWithArray:self.mapView.annotations]; 
    NSSet *after = [NSSet setWithArray:annotations]; 

    // Annotations circled in blue shared by both sets 
    NSMutableSet *toKeep = [NSMutableSet setWithSet:before]; 
    [toKeep intersectSet:after]; 

    // Annotations circled in green 
    NSMutableSet *toAdd = [NSMutableSet setWithSet:after]; 
    [toAdd minusSet:toKeep]; 

    // Annotations circled in red 
    NSMutableSet *toRemove = [NSMutableSet setWithSet:before]; 
    [toRemove minusSet:after]; 

    // These two methods must be called on the main thread 
    [[NSOperationQueue mainQueue] addOperationWithBlock:^{ 
        [self.mapView addAnnotations:[toAdd allObjects]]; 
        [self.mapView removeAnnotations:[toRemove allObjects]]; 
    }]; 
} 
</code></pre>

<p>这样我们尽可能的确保在主线程上做少量的工作，从而提升地图滑动的流畅性。</p>

<p>接下来我们来看下如何绘制标注，并且在标注上显示出来旅馆的个数。最后我们给标注加上点击事件，这样使得app从头到脚都可以表现的非常完美。</p>

<p>绘制标注
由于我们在地图上并没有完全显示出全部旅馆，所以我们需要在剩余的这些标注上表现出真实的旅馆总量。</p>

<p>首先创建一个圆形的标注，中间显示合并后的个数，也就是旅馆的真实总量。这个圆形的大小同样可以反映出合并后的个数。</p>

<p>为了实现这个需求，我们要找出一个方程式，允许我们在1到500+的数值中生成一个缩小后的数值。用这个数值来作为标注的大小。我们将用到以下的方程式。</p>

<p><img src="/images/posts/2013-12-28-how-to-handle-large-amounts-of-data-on-maps/4673_131216114009_1.png"></p>

<p>x值较低的时候f(x)增长的比较快，x在值变大的时候f(x)增长变缓慢，β值用来控制f(x)趋于1的速度。α值影响最小值（在我们的项目中，我们的最小合并值（也就是1）能占总共最大值的60%）。</p>

<pre><code class="obj-c">static CGFloat const TBScaleFactorAlpha = 0.3; 
static CGFloat const TBScaleFactorBeta = 0.4; 

CGFloat TBScaledValueForValue(CGFloat value) 
{ 
    return 1.0 / (1.0 + expf(-1 * TBScaleFactorAlpha * powf(value, TBScaleFactorBeta))); 
} 

- (void)setCount:(NSUInteger)count 
{ 
    _count = count; 

    // Our max size is (44,44) 
    CGRect newBounds = CGRectMake(0, 0, roundf(44 * TBScaledValueForValue(count)), roundf(44 * TBScaledValueForValue(count))); 
    self.frame = TBCenterRect(newBounds, self.center); 

    CGRect newLabelBounds = CGRectMake(0, 0, newBounds.size.width / 1.3, newBounds.size.height / 1.3); 
    self.countLabel.frame = TBCenterRect(newLabelBounds, TBRectCenter(newBounds)); 
    self.countLabel.text = [@(_count) stringValue]; 

    [self setNeedsDisplay]; 
} 
</code></pre>

<p>现在标注的大小已经OK了。让我们再来把这个标注做漂亮些。</p>

<pre><code class="obj-c">- (void)setupLabel 
{ 
    _countLabel = [[UILabel alloc] initWithFrame:self.frame]; 
    _countLabel.backgroundColor = [UIColor clearColor]; 
    _countLabel.textColor = [UIColor whiteColor]; 
    _countLabel.textAlignment = NSTextAlignmentCenter; 
    _countLabel.shadowColor = [UIColor colorWithWhite:0.0 alpha:0.75]; 
    _countLabel.shadowOffset = CGSizeMake(0, -1); 
    _countLabel.adjustsFontSizeToFitWidth = YES; 
    _countLabel.numberOfLines = 1; 
    _countLabel.font = [UIFont boldSystemFontOfSize:12]; 
    _countLabel.baselineAdjustment = UIBaselineAdjustmentAlignCenters; 
    [self addSubview:_countLabel]; 
} 

- (void)drawRect:(CGRect)rect 
{ 
    CGContextRef context = UIGraphicsGetCurrentContext(); 

    CGContextSetAllowsAntialiasing(context, true); 

    UIColor *outerCircleStrokeColor = [UIColor colorWithWhite:0 alpha:0.25]; 
    UIColor *innerCircleStrokeColor = [UIColor whiteColor]; 
    UIColor *innerCircleFillColor = [UIColor colorWithRed:(255.0 / 255.0) green:(95 / 255.0) blue:(42 / 255.0) alpha:1.0]; 

    CGRect circleFrame = CGRectInset(rect, 4, 4); 

    [outerCircleStrokeColor setStroke]; 
    CGContextSetLineWidth(context, 5.0); 
    CGContextStrokeEllipseInRect(context, circleFrame); 

    [innerCircleStrokeColor setStroke]; 
    CGContextSetLineWidth(context, 4); 
    CGContextStrokeEllipseInRect(context, circleFrame); 

    [innerCircleFillColor setFill]; 
    CGContextFillEllipseInRect(context, circleFrame); 
} 
</code></pre>

<h2>添加最后的touch事件</h2>

<p>目前的标注可以很好的呈现出我们的数据了，让我们最后添加一些touch事件来让我们的app用起来更有趣。</p>

<p>首先，我们需要为新添加到地图上的标注做一个动画。如果没有添加动画的话，新的标注就会在地图上突然出现，体验效果将会大打折扣。</p>

<pre><code class="obj-c">- (void)addBounceAnnimationToView:(UIView *)view 
{ 
    CAKeyframeAnimation *bounceAnimation = [CAKeyframeAnimation animationWithKeyPath:@"transform.scale"]; 

    bounceAnimation.values = @[@(0.05), @(1.1), @(0.9), @(1)]; 

    bounceAnimation.duration = 0.6; 
    NSMutableArray *timingFunctions = [[NSMutableArray alloc] init]; 
    for (NSInteger i = 0; i &lt; 4; i++) { 
        [timingFunctions addObject:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]]; 
    } 
    [bounceAnimation setTimingFunctions:timingFunctions.copy]; 
    bounceAnimation.removedOnCompletion = NO; 

    [view.layer addAnimation:bounceAnimation forKey:@"bounce"]; 
} 

- (void)mapView:(MKMapView *)mapView didAddAnnotationViews:(NSArray *)views 
{ 
    for (UIView *view in views) { 
        [self addBounceAnnimationToView:view]; 
    } 
} 
</code></pre>

<p>接下来，我们想要根据地图的缩放比例来改变在合并时的小单元格（cell）的大小。在地图进行放大时，小单元格变小。所以我们需要定义一下当前地图的缩放比例。也就是<code>scale=mapView.bounds.size.width/mapView.visibleMapRect.size.width</code>:</p>

<pre><code class="obj-c">NSInteger TBZoomScaleToZoomLevel(MKZoomScale scale) 
{ 
    double totalTilesAtMaxZoom = MKMapSizeWorld.width / 256.0; 
    NSInteger zoomLevelAtMaxZoom = log2(totalTilesAtMaxZoom); 
    NSInteger zoomLevel = MAX(0, zoomLevelAtMaxZoom + floor(log2f(scale) + 0.5)); 

    return zoomLevel; 
} 
</code></pre>

<p>我们为每个地图缩放的比例都定义一个常量。</p>

<pre><code class="obj-c">float TBCellSizeForZoomScale(MKZoomScale zoomScale) 
{ 
    NSInteger zoomLevel = TBZoomScaleToZoomLevel(zoomScale); 

    switch (zoomLevel) { 
        case 13: 
        case 14: 
        case 15: 
            return 64; 
        case 16: 
        case 17: 
        case 18: 
            return 32; 
        case 19: 
            return 16; 

        default: 
            return 88; 
    } 
} 
</code></pre>

<p>现在我们放大地图，我们将看到逐渐变小的标注，直到最后我们能看到代表每个旅馆的那个标注。</p>

<p><a href="https://github.com/thoughtbot/TBAnnotationClustering">完整源代码在这里</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[值对象]]></title>
    <link href="http://orinchen.github.io/blog/2013/12/27/value-object/"/>
    <updated>2013-12-27T12:45:00+08:00</updated>
    <id>http://orinchen.github.io/blog/2013/12/27/value-object</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://ansonzhao.com/">Anson</a> 翻译自 <a href="http://www.objc.io/issue-7/value-objects.html">Value Objects</a></p>

<p>在这篇文章中，我们将看看如何用<em>Objective-C</em>语言编写值对象。在编写时，我们将会接触到<em>Objective-C</em>中的重要协议和方法。一个值对象是一个包含一些值的对象，并且可以进行相等比较。通常值对象可以被用作模型对象。例如，考虑一个简单的<em>Person</em>对象：</p>

<!--more-->


<pre><code class="objective-c">@interface Person : NSObject

@property (nonatomic,copy) NSString* name;
@property (nonatomic,strong) NSDate* birthDate;
@property (nonatomic) NSUInteger numberOfKids;

@end
</code></pre>

<p>创建这些类型的对象是我们工作的面包和黄油（译者注：基本元素），虽然这些对象看上去很简单，但是仍然包含许多微妙之处。</p>

<p>有一件事，我们很多人硬性的认为这些对象应该是一成不变的。一旦你创建了一个<em>Person</em>对象，它不可能被改变。我们将在稍后涉及到可变性这个问题。</p>

<h2>属性</h2>

<p>首先要注意的是我们使用属性来定义一个<em>Person</em>的特征。创建属性是想当机械的：对于普通对象的属性，你设置它们为<code>nonatomic</code>和<code>strong</code>，而对于标量属性你只需要设置<code>nonatomic</code>。默认情况下，它们也是<code>assign</code>。有一个例外，对于具有可变副本的属性，你想将他们定义为<code>copy</code>。例如，<code>name</code>属性的类型是<code>NSString</code>，有可能出现的情况是，有人创建了一个<em>Person</em>对象，并指定类型为<code>NSMutableString</code>的值。然后一段时间后，他或她可能会改变这个可变的字符串。如果我们的属性是<code>strong</code>而不是<code>copy</code>，我们的<em>Person</em>对象会随之改变，这不是我们想要的。对于容器类型也是一样的，例如数组或者字典。</p>

<p>请注意，这个拷贝是浅拷贝，容器可能还包含可变对象。例如，如果你有一个<code>NSMutableArray *a</code>包含有<code>NSMutableDictionary</code>元素，则<code>[a copy]</code>将会给你一个不可变数组，但是元素是相同的<code>NSMutableDictionary</code>对象。正如我们稍后将看到的，不可变对象的拷贝是无成本的，但是它增加了引用计数。</p>

<p>在旧的代码中，你可能看不到属性，因为他们是相对近期才加入到<em>Objective-C</em>语言的。代替现有属性，有可能会看到自定义的<em>getter</em>和<em>setter</em>方法，或纯实例变量。对于现在的代码，似乎似乎大多数人都同意使用属性，这也是我们所推荐的。</p>

<h3>更多阅读</h3>

<p><a href="http://stackoverflow.com/questions/387959/nsstring-property-copy-or-retain">NSString:copy or retian</a></p>

<h2>初始化方法</h2>

<p>如果我们想要不可变对象，我们应该确保他们被创建后不能进行修改。我们可以通过添加一个初始化方法和在接口里使我们的属性只读来做到这一点。我们的接口将如下所示：</p>

<pre><code class="objective-c">@interface Person : NSObject

@property (nonatomic,copy,readonly) NSString* name;
@property (nonatomic,strong,readonly) NSDate* birthDate;
@property (nonatomic,readonly) NSUInteger numberOfKids;

- (instancetype)initWithName:(NSString*)name
                   birthDate:(NSDate*)birthDate
                numberOfKids:(NSUInteger)numberOfKids;

@end
</code></pre>

<p>然后，在我们的实现中，我们必须使我们的属性<em>readwrite</em>，从而生成实例变量：</p>

<pre><code class="objective-c">@interface Person ()

@property (nonatomic,copy) NSString* name;
@property (nonatomic,strong) NSDate* birthDate;
@property (nonatomic) NSUInteger numberOfKids;


@end

@implementation Person

- (instancetype)initWithName:(NSString*)name
                   birthDate:(NSDate*)birthDate
                numberOfKids:(NSUInteger)numberOfKids
{
    self = [super init];
    if (self) {
        self.name = name;
        self.birthDate = birthDate;
        self.numberOfKids = numberOfKids;
    }
    return self;
}

@end
</code></pre>

<p>现在我们可以构造新的<em>Person</em>对象，但不能修改它们了。这是非常有帮助的，当编写与<em>Person</em>对象工作的其他类时，我们知道我们正在工作的值不能改变。</p>

<h2>相等比较</h2>

<p>要比较是否相等，我们必须实现<code>isEqual:</code>方法。我们希望<code>isEqual:</code>返回true当且仅当所有的属性都相等。由<em>Mike Ash</em>（<a href="http://www.mikeash.com/pyblog/friday-qa-2010-06-18-implementing-equality-and-hashing.html">实现相等和散列</a>）和<em>NSHipster</em>（<a href="http://nshipster.com/equality/">相等</a>）写的两篇很好的文章解释了如何做到这点。首先，让我们写<code>isEqual:</code>：</p>

<pre><code class="objective-c">- (BOOL)isEqual:(id)obj
{
    if(![obj isKindOfClass:[Person class]]) return NO;

    Person* other = (Person*)obj;

    BOOL nameIsEqual = self.name == other.name || [self.name isEqual:other.name];
    BOOL birthDateIsEqual = self.birthDate == other.birthDate || [self.birthDate isEqual:other.birthDate];
    BOOL numberOfKidsIsEqual = self.numberOfKids == other.numberOfKids;
    return nameIsEqual &amp;&amp; birthDateIsEqual &amp;&amp; numberOfKidsIsEqual;
}
</code></pre>

<p>现在，我们检查是否我们是相同类型的类。如果不是，我们肯定不相等。然后对每个对象的属性，我们检查是否指针是相等的。<code>||</code>左侧的运算数似乎是多余的，但如果两个属性都为<code>nil</code>则返回<code>YES</code>。为了比较标量值相等像<code>NSUInteger</code>，我们可以只使用<code>==</code>。</p>

<p>有一件事值得注意：这里我们分成不同的属性到他们自己的布尔值里。在实践中，可能将它们合成一个大的条件更有意义，因为这样你直接得到惰性求值。在上面的例子中，如果名字不相等，我们就不需要检查任何其他的属性。通过把所有组合成一个<code>if</code>语句，我们直接得到优化。</p>

<p>下一步，按照<a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/isEqual:">这个文档</a>，我们需要实现一个哈希函数也是如此。Apple说：</p>

<blockquote><p>如果两个对象相等，他们必须有相同的哈希值。如果你在子类中定义了<code>isEqual:</code>，并且打算把该子类的实例放入集合中，这最后一点就特别重要了。请确保你在你的子类中也定义了哈希。</p></blockquote>

<p>首先，我们可以尝试运行下面没有实现哈希函数的代码：</p>

<pre><code class="objective-c">Person* p1 = [[Person alloc] initWithName:name birthDate:start numberOfKids:0];
Person* p2 = [[Person alloc] initWithName:name birthDate:start numberOfKids:0];
NSDictionary* dict = @{p1: @"one", p2: @"two"};
NSLog(@"%@", dict);
</code></pre>

<p>我第一次跑了上面的代码，一切都很好，在字典中有两个项目。第二次，只有一个了。事情变得非常不可预测了，所以我们照着文档说的来做了。</p>

<p>正如你可能还记得您的计算机科学课程中，写一个好的哈希函数不是很容易的。一个好的哈希函数必须是确定性的和均匀的。确定性意味着，在相同的输入下需要生成相同的哈希值。均匀表示哈希函数的结果应该均匀地将输入映射在输出范围内。你的输出越均匀，你在集合中使用这些对象的性能越好。</p>

<p>首先，为了弄清楚，让我们来看看当我们没有一个哈希函数发生了什么，我们尝试使用<em>Person</em>对象作为字典的键：</p>

<pre><code class="objective-c">NSMutableDictionary* dictionary = [NSMutableDictionary dictionary];

NSDate* start = [NSDate date];
for (int i = 0; i &lt; 50000; i++) {
    NSString* name = randomString();
    Person* p = [[Person alloc] initWithName:name birthDate:[NSDate date] numberOfKids:i++];
    [dictionary setObject:@"value" forKey:p];
}
NSLog(@"%f", [[NSDate date] timeIntervalSinceDate:start]);
</code></pre>

<p>这在我的机器上运行需要29秒。相比之下，当我们实现一个基本的哈希函数，相同的代码运行只需要0.4秒。这不是合适的基准，但也给出了一个好的迹象，为什么要实现一个适当的哈希函数是很重要的。 对于Person类，我们可以用这样的哈希函数开始：</p>

<pre><code class="objective-c">- (NSUInteger)hash
{
    return self.name.hash ^ self.birthDate.hash ^ self.numberOfKids;
}
</code></pre>

<p>这将从我们的属性中产生三个哈希值并且XOR他们。在这种情况下，对我们来说已经足够了，因为<code>NSString</code>的哈希函数对于短字符串来说很好（过去表现良好的字符串<a href="http://www.abakia.de/blog/2012/12/05/nsstring-hash-is-bad/">最多96个字符</a>，但是现在已经改变了。见<a href="http://www.opensource.apple.com/source/CF/CF-855.11/CFString.c">CFString.c</a>，寻找哈希）。对于严重的散列，你的哈希函数取决于你拥有的数据。这被<a href="http://www.opensource.apple.com/source/CF/CF-855.11/CFString.c">Mike Ash</a>的文章和<a href="http://www.burtleburtle.net/bob/hash/spooky.html">其他地方</a>所提及。</p>

<p>在哈希的<a href="https://developer.apple.com/library/mac/documentation/cocoa/Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/hash">文档</a>里，有如下的段落：</p>

<blockquote><p>如果一个可变对象被添加到使用哈希值来确定集合中对象位置的集合中，当对象在集合中，对象的哈希方法返回的值必须不能改变。因此，无论是哈希方法必须不依赖于任何对象的内部状态信息，还是当对象在集合中你必须确保该对象的内部状态信息不会改变。因此，例如，一个可变字典可以放入一个哈希表中，但是当它在那里你不能改变它。（请注意，可能很难知道给定的对象是否在一个集合中。）</p></blockquote>

<p>这是为了确保你的对象是不可变的另一个非常重要的原因。然后，你甚至不必担心这个问题了。</p>

<h3>更多阅读</h3>

<ul>
<li><a href="https://gist.github.com/steipete/6133152">A hash function for CGRect</a></li>
<li><a href="http://www.burtleburtle.net/bob/hash/doobs.html">A Hash Function for Hash Table Lookup</a></li>
<li><a href="http://www.burtleburtle.net/bob/hash/spooky.html">SpookyHash: a 128-bit noncryptographic hash</a></li>
<li><a href="http://computinglife.wordpress.com/2008/11/20/why-do-hash-functions-use-prime-numbers/">Why do hash functions use prime numbers?</a></li>
</ul>


<h2>NSCopying</h2>

<p>为了确保我们的对象是有用的，可以方便的实现<code>NSCopying</code>协议。让我们举例来说，在容器类中使用它们。对于我们类中的一个可变的变量，<code>NSCopying</code>可以被这样实现：</p>

<pre><code class="obj-c">- (id)copyWithZone:(NSZone *)zone
{
    Person* p = [[Person allocWithZone:zone] initWithName:self.name
                                                birthDate:self.birthDate
                                             numberOfKids:self.numberOfKids];
    return p;
}
</code></pre>

<p>然而，在协议文档中，他们提到另一种方式来实现<code>NSCopying</code>：</p>

<blockquote><p>当类和它的内容是不可变的，通过保留原有的实现NSCopying，而不是创建一个新的副本。</p></blockquote>

<p>因此，对于我们不可变的版本，我们只要这样做：</p>

<pre><code class="obj-c">- (id)copyWithZone:(NSZone *)zone
{
    return self;
}
</code></pre>

<h2>NSCoding</h2>

<p>如果我们要序列化我们的对象，我们可以通过实现<code>NSCoding</code>来做到这一点。该协议存在两个必需的方法：</p>

<pre><code class="obj-c">- (id)initWithCoder:(NSCoder *)decoder
- (void)encodeWithCoder:(NSCoder *)encoder
</code></pre>

<p>实现这个和实现相等方法同样简单，也比较机械：</p>

<pre><code class="obj-c">- (id)initWithCoder:(NSCoder *)aDecoder
{
    self = [super init];
    if (self) {
        self.name = [aDecoder decodeObjectForKey:@"name"];
        self.birthDate = [aDecoder decodeObjectForKey:@"birthDate"];
        self.numberOfKids = [aDecoder decodeIntegerForKey:@"numberOfKids"];
    }
    return self;
}

- (void)encodeWithCoder:(NSCoder *)aCoder
{
    [aCoder encodeObject:self.name forKey:@"name"];
    [aCoder encodeObject:self.birthDate forKey:@"birthDate"];
    [aCoder encodeInteger:self.numberOfKids forKey:@"numberOfKids"];
}
</code></pre>

<p>关于它可以从<a href="http://nshipster.com/nscoding/">NSHipster</a>和<a href="http://www.mikeash.com/pyblog/friday-qa-2013-08-30-model-serialization-with-property-lists.html">Mike Ash</a>的博客中阅读更多。顺便说一句，当处理不受信任的来源，如数据来自网络，<em>不要</em>使用<code>NSCoding</code>。因为数据可能被篡改。通过<a href="https://developer.apple.com/library/mac/documentation/security/conceptual/securecodingguide/Articles/ValidatingInput.html#//apple_ref/doc/uid/TP40007246-SW9">修改存档的数据</a>，它很可能要执行远程代码进行攻击。取而代之，使用<a href="http://nshipster.com/nssecurecoding/">NSSecureCoding</a>或像<em>JSON</em>的自定义格式。</p>

<h2>Mantle</h2>

<p>现在我们留下了一个问题：我们可以自动化它吗？事实证明，我们可以做到。一种方法是代码生成，但幸运的是有一个更好的选择：<a href="https://github.com/github/Mantle">Mantle</a>。<em>Mantle</em>使用内省(introspection)来产生<code>isEqual:</code>和哈希。此外，它提供了一些方法来帮助你创建字典，然后可以用于写入和读取JSON。当然，一般运行时这样做将不会像自己写的代码一样有效率，但在另一方面，自动执行是一个更不容易出错的过程。</p>

<h2>可变性</h2>

<p>在<em>C</em>语言和<em>Objective-C</em>语言中，可变的值是默认值。在某种程度上，它们是非常方便的，因为你可以在任何时候改变任何东西。当建立较小的系统，这应该是没有问题的。然而，正如我们许多人了解的方法，建立规模更大的系统时，事情是不可变时会相当容易。在<em>Objective-C</em>中，我们已经使用不可变对象很长时间了，并且现在其他语言也开始添加。</p>

<p>我们来看看可变对象的两个问题。一个是当你不希望它改变时它们可能会改变，另一个是在多线程环境中使用可变对象。</p>

<h3>意想不到的变化</h3>

<p>假设我们有一个表视图控制器，其中有一个<em>People</em>属性：</p>

<pre><code class="obj-c">@interface ViewController : UITableViewController

@property (nonatomic, strong) NSArray* people;

@end
</code></pre>

<p>而在我们的实现里，我们只是映射每个数组元素到一个单元格：</p>

<pre><code class="obj-c">- (NSInteger)numberOfSectionsInTableView:(UITableView*)tableView
{
    return 1;
}

- (NSInteger)tableView:(UITableView*)tableView numberOfRowsInSection:(NSInteger)section
{
    return self.people.count;
}
</code></pre>

<p>现在，在设置了以上视图控制器的代码中，我们可能有这样的代码：</p>

<pre><code class="obj-c">self.items = [NSMutableArray array];
[self loadItems]; // Add 100 items to the array
tableVC.people = self.items;
[self.navigationController pushViewController:tableVC animated:YES];
</code></pre>

<p>表视图将开始调用方法，如<code>tableView:numberOfRowsInSection:</code>，开始一切都很好，但是假设在某些时候，我们执行以下操作</p>

<pre><code class="obj-c">[self.items removeObjectAtIndex:1];
</code></pre>

<p>这改变了我们的<em>items</em>数组，但是它也改变了我们表视图控制器里的<em>People</em>数组。如果我们这样做而没有和表视图控制器有任何进一步的沟通，表视图将仍然认为有100个项目，而我们的数组只包含99个。不好的事情将会发生。取而代之，我们应该做的是以<code>copy</code>声明我们的属性：</p>

<pre><code class="obj-c">@interface ViewController : UITableViewController

@property (nonatomic, copy) NSArray* items;

@end
</code></pre>

<p>现在，无论什么时候我们分配一个可变的数组给<em>items</em>，一个不可变的副本将会创建。如果我们分配一个常规（不可变）的数组的值，拷贝操作是无害的，它仅仅增加了引用计数。</p>

<h3>多线程</h3>

<p>假设我们有一个可变对象，<em>Account</em>，代表一个银行账户，它有一个方法<code>transfer:to:</code>：</p>

<pre><code class="obj-c">- (void)transfer:(double)amount to:(Account*)otherAccount
{
    self.balance = self.balance - amount;
    otherAccount.balance = otherAccount.balance + amount;
}
</code></pre>

<p>多线程的代码可以在许多方面产生错误。例如，如果线程A读取<code>self.balance</code>，线程B可能会在线程A继续之前修改它。对于所有涉及到的危险的一个很好的解释，请参阅我们的<a href="http://www.objc.io/issue-2/">第二个问题</a>。</p>

<p>如果我们将它替换为不可变对象，事情就容易多了。我们不能对其进行修改，这迫使我们在一个完全不同的层次上提供可变性，产生更简单的代码。</p>

<h3>缓存</h3>

<p>另一件事，不可变性可以帮助的是在缓存值的时候。例如，假设你已经解析了一个<em>markdown</em>文档为一个包含所有不同元素节点的树形结构。如果你想生成的另外的<em>HTML</em>，你可以缓存这个值，因为你知道没有任何子节点会改变。如果你有可变对象，你则需要每次从零开始生成<em>HTML</em>，或构建优化并观察每一个单独的对象。和不变性相比，你不必担心无效的缓存。当然，这可能会带来性能损失。在几乎所有情况下，然而，简单将超过在性能上的略有下降。</p>

<h3>在其他语言里的不可变性</h3>

<p>不可变对象是灵感来自于像<a href="http://www.haskell.org/haskellwiki/Haskell">Haskell</a>的函数式编程语言的概念之一。在<em>Haskell</em>中，值默认是不可变的。<em>Haskell</em>程序通常有一个<a href="http://en.wikipedia.org/wiki/Purely_functional">单纯功能</a>的核心，里面没有可变对象，没有状态，而且没有副作用，像I/O。</p>

<p>我们可以在<em>Objective-C</em>编程中借鉴这个。在可能的情况下使用不可变对象，我们的项目将变得更容易测试。<a href="https://www.destroyallsoftware.com/talks/boundaries">Gary Bernhardt有一个很棒的讨论</a>，显示了如何使用不可变对象来帮助我们写出更好的软件。在这个讨论中，他使用的是<em>Ruby</em>，但是其概念也同样适用于<em>Objective-C</em>语言。</p>

<h3>进一步阅读</h3>

<ul>
<li><a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/CocoaEncyclopedia/ObjectMutability/ObjectMutability.html#//apple_ref/doc/uid/TP40010810-CH5-SW1">Cocoa Encyclopedia: Object Mutability</a></li>
<li><a href="http://garbagecollective.quora.com/Mutability-aliasing-and-the-caches-you-didnt-know-you-had">Mutability and Caching</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
