<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Objective-c | O's World]]></title>
  <link href="http://orinchen.github.io/blog/categories/objective-c/atom.xml" rel="self"/>
  <link href="http://orinchen.github.io/"/>
  <updated>2014-12-23T16:22:14+08:00</updated>
  <id>http://orinchen.github.io/</id>
  <author>
    <name><![CDATA[Orin Chen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[谈 Objective-C Block 的实现]]></title>
    <link href="http://orinchen.github.io/blog/2014/03/26/a-look-inside-blocks/"/>
    <updated>2014-03-26T14:09:38+08:00</updated>
    <id>http://orinchen.github.io/blog/2014/03/26/a-look-inside-blocks</id>
    <content type="html"><![CDATA[<p>本文转载自:<a href="http://blog.devtang.com/blog/2013/07/28/a-look-inside-blocks/">唐巧的技术博客</a></p>

<h2>前言</h2>

<p><a href="http://blog.parse.com/2013/02/05/objective-c-blocks-quiz/">这里</a>有关于 <strong>block</strong> 的5道测试题，建议你阅读本文之前先做一下测试。</p>

<p>先介绍一下什么是闭包。在 Wikipedia 上，<a href="http://en.wikipedia.org/wiki/Closure_(computer_science">闭包的定义</a>)是:</p>

<blockquote><p>In programming languages, a closure is a function or reference to a function together with a referencing environment—a table storing a reference to each of the non-local variables (also called free variables or upvalues) of that function.</p></blockquote>

<p>翻译过来就是：</p>

<blockquote><p>闭包是一个函数（或指向函数的指针），再加上该函数执行的外部的上下文变量（有时候也称作自由变量）。</p></blockquote>

<p><strong>block</strong> 实际上就是 Objective-C 语言对于闭包的实现。 <strong>block</strong> 配合上 <strong>dispatch_queue</strong>，可以方便地实现简单的多线程编程和异步编程，关于这个，我之前写过一篇文章介绍：<a href="http://blog.devtang.com/blog/2012/02/22/use-gcd/">《使用GCD》</a>。</p>

<p>本文主要介绍 Objective-C 语言的 <strong>block</strong> 在编译器中的实现方式。主要包括：</p>

<ol>
<li><strong>block</strong> 的内部实现数据结构介绍</li>
<li><strong>block</strong> 的三种类型及其相关的内存管理方式</li>
<li><strong>block</strong> 如何通过 <strong>capture</strong> 变量来达到访问函数外的变量</li>
</ol>


<!--more-->


<h2>实现方式</h2>

<h3>数据结构定义</h3>

<p>block的数据结构定义如下（图片来自<a href="http://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/">这里</a>)：</p>

<p><img src="/images/posts/2014-03-26-a-look-inside-blocks/block-struct.jpg"></p>

<p>对应的结构体定义如下：</p>

<pre><code class="objc">struct Block_descriptor {
    unsigned long int reserved;
    unsigned long int size;
    void (*copy)(void *dst, void *src);
    void (*dispose)(void *);
};

struct Block_layout {
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(void *, ...);
    struct Block_descriptor *descriptor;
    /* Imported variables. */
};
</code></pre>

<p>通过该图，我们可以知道，一个 <strong>block</strong> 实例实际上由6部分构成：</p>

<ol>
<li><strong>isa</strong> 指针，所有对象都有该指针，用于实现对象相关的功能。</li>
<li><strong>flags</strong>，用于按 bit 位表示一些 <strong>block</strong> 的附加信息，本文后面介绍 <strong>block copy</strong> 的实现代码可以看到对该变量的使用。</li>
<li><strong>reserved</strong>，保留变量。</li>
<li><strong>invoke</strong>，函数指针，指向具体的 <strong>block</strong> 实现的函数调用地址。</li>
<li><strong>descriptor</strong>， 表示该 <strong>block</strong> 的附加描述信息，主要是 <strong>size</strong> 大小，以及 <strong>copy</strong> 和 <strong>dispose</strong>函数的指针。</li>
<li><strong>variables</strong>，<strong>capture</strong> 过来的变量，<strong>block</strong> 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。</li>
</ol>


<p>该数据结构和后面的 clang 分析出来的结构实际是一样的，不过仅是结构体的嵌套方式不一样。但这一点我一开始没有想明白，所以也给大家解释一下，如下2个结构体 SampleA 和 SampleB 在内存上是完全一样的，原因是结构体本身并不带有任何额外的附加信息。</p>

<pre><code class="objc">struct SampleA {
    int a;
    int b;
    int c;
};

struct SampleB {
    int a;
    struct Part1 {
        int b;
    };
    struct Part2 {
        int c;
    };
};
</code></pre>

<p>在 Objective-C 语言中，一共有3种类型的 <strong>block</strong>：</p>

<ol>
<li><strong>_NSConcreteGlobalBlock</strong> 全局的静态 <strong>block</strong>，不会访问任何外部变量。</li>
<li><strong>_NSConcreteStackBlock</strong> 保存在栈中的 <strong>block</strong>，当函数返回时会被销毁。</li>
<li><strong>_NSConcreteMallocBlock</strong> 保存在堆中的 <strong>block</strong>，当引用计数为0时会被销毁。</li>
</ol>


<p>我们在下面会分别来查看它们各自的实现方式上的差别。</p>

<h3>研究工具：clang</h3>

<p>为了研究编译器是如何实现 <strong>block</strong> 的，我们需要使用 clang。clang 提供一个命令，可以将 Objetive-C 的源码改写成 c 语言的，借此可以研究 <strong>block</strong> 具体的源码实现方式。该命令是</p>

<pre><code>clang -rewrite-objc block.c
</code></pre>

<h3>NSConcreteGlobalBlock 类型的 block 的实现</h3>

<p>我们先新建一个名为 block1.c 的源文件：</p>

<pre><code class="objc">#include &lt;stdio.h&gt;

int main()
{
    ^{ printf("Hello, World!\n"); } ();
    return 0;
}
</code></pre>

<p>然后在命令行中输入 <code>clang -rewrite-objc block1.c</code> 即可在目录中看到 clang 输出了一个名为 block1.cpp 的文件。该文件就是 block 在 c 语言实现，我将 block1.cpp 中一些无关的代码去掉，将关键代码引用如下：</p>

<pre><code class="objc">struct __block_impl {
    void *isa;
    int Flags;
    int Reserved;
    void *FuncPtr;
};

struct __main_block_impl_0 {
    struct __block_impl impl;
    struct __main_block_desc_0* Desc;
    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
        impl.isa = &amp;_NSConcreteStackBlock;
        impl.Flags = flags;
        impl.FuncPtr = fp;
        Desc = desc;
    }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
    printf("Hello, World!\n");
}

static struct __main_block_desc_0 {
    size_t reserved;
    size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0) };

int main()
{
    (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA) ();
    return 0;
}
</code></pre>

<p>下面我们就具体看一下是如何实现的。<strong>__main_block_impl_0</strong>  就是该 <strong>block</strong> 的实现，从中我们可以看出：</p>

<ol>
<li>一个 <strong>block</strong> 实际是一个对象，它主要由一个 <strong>isa</strong> 和 一个 <strong>impl</strong> 和 一个 <strong>descriptor</strong> 组成。</li>
<li>在本例中，<strong>isa</strong> 指向 <strong>_NSConcreteGlobalBlock</strong>， 主要是为了实现对象的所有特性，在此我们就不展开讨论了。</li>
<li>由于 clang 改写的具体实现方式和 LLVM 不太一样，并且这里没有开启 ARC。所以这里我们看到 <strong>isa</strong> 指向的还是 <strong>_NSConcreteStackBlock</strong>。但在 LLVM 的实现中，开启 ARC 时，<strong>block</strong> 应该是 <strong>_NSConcreteGlobalBlock</strong> 类型，具体可以看<a href="http://blog.parse.com/2013/02/05/objective-c-blocks-quiz/">《objective-c-blocks-quiz》</a>第二题的解释。</li>
<li><strong>impl</strong> 是实际的函数指针，本例中，它指向 <strong>__main_block_func_0</strong>。这里的 <strong>impl</strong> 相当于之前提到的 <strong>invoke</strong> 变量，只是 clang 编译器对变量的命名不一样而已。</li>
<li><strong>descriptor</strong> 是用于描述当前这个 <strong>block</strong> 的附加信息的，包括结构体的大小，需要 <strong>capture</strong> 和 <strong>dispose</strong> 的变量列表等。结构体大小需要保存是因为，每个 <strong>block</strong> 因为会 <strong>capture</strong> 一些变量，这些变量会加到 <strong>__main_block_impl_0</strong> 这个结构体中，使其体积变大。在该例子中我们还看不到相关 <strong>capture</strong> 的代码，后面将会看到。</li>
</ol>


<h3>NSConcreteStackBlock 类型的block的实现</h3>

<p>我们另外新建一个名为 block2.c 的文件，输入以下内容：</p>

<pre><code class="objc">#include &lt;stdio.h&gt;

int main() {
    int a = 100;
    void (^block2)(void) = ^{
        printf("%d\n", a);
    };
    block2();

    return 0;
}
</code></pre>

<p>用之前提到的 clang 工具，转换后的关键代码如下：</p>

<pre><code class="objc">struct __main_block_impl_0 {
    struct __block_impl impl;
    struct __main_block_desc_0* Desc;
    int a;
    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) {
        impl.isa = &amp;_NSConcreteStackBlock;
        impl.Flags = flags;
        impl.FuncPtr = fp;
        Desc = desc;
    }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
    int a = __cself-&gt;a; // bound by copy
    printf("%d\n", a);
}

static struct __main_block_desc_0 {
    size_t reserved;
    size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};

int main()
{
    int a = 100;
    void (*block2)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a);
    ((void (*)(__block_impl *))((__block_impl *)block2)-&gt;FuncPtr)((__block_impl *)block2);

    return 0;
}
</code></pre>

<p>在本例中，我们可以看到：</p>

<ol>
<li>本例中，<strong>isa</strong> 指向 <strong>_NSConcreteStackBlock</strong>，说明这是一个分配在栈上的实例。</li>
<li><strong>main_block_impl_0</strong>  中增加了一个变量 <strong>a</strong>，在 <strong>block</strong> 中引用的变量 <strong>a</strong> 实际是在申明 <strong>block</strong> 时，被复制到 <strong>main_block_impl_0</strong>结构体中的那个变量 <strong>a</strong>。因为这样，我们就能理解，在 <strong>block</strong> 内部修改变量a的内容，不会影响外部的实际变量 <strong>a</strong>。</li>
<li><strong>main_block_impl_0</strong> 中由于增加了一个变量 <strong>a</strong>，所以结构体的大小变大了，该结构体大小被写在了 <strong>main_block_desc_0</strong> 中。</li>
</ol>


<p>我们修改上面的源码，在变量前面增加 <strong>__block</strong> 关键字：</p>

<pre><code class="objc">#include &lt;stdio.h&gt;

int main()
{
    __block int i = 1024;
    void (^block1)(void) = ^{
        printf("%d\n", i);
        i = 1023;
    };
    block1();
    return 0;
}
</code></pre>

<p>生成的关键代码如下，可以看到，差异相当大：</p>

<pre><code class="objc">struct __Block_byref_i_0 {
    void *__isa;
    __Block_byref_i_0 *__forwarding;
    int __flags;
    int __size;
    int i;
};

struct __main_block_impl_0 {
    struct __block_impl impl;
    struct __main_block_desc_0* Desc;
    __Block_byref_i_0 *i; // by ref
    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&gt;__forwarding) {
        impl.isa = &amp;_NSConcreteStackBlock;
        impl.Flags = flags;
        impl.FuncPtr = fp;
        Desc = desc;
    }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
    __Block_byref_i_0 *i = __cself-&gt;i; // bound by ref

    printf("%d\n", (i-&gt;__forwarding-&gt;i));
    (i-&gt;__forwarding-&gt;i) = 1023;
}

static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);}

static struct __main_block_desc_0 {
    size_t reserved;
    size_t Block_size;
    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
    void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};

int main()
{
    __attribute__((__blocks__(byref))) __Block_byref_i_0 i = {(void*)0,(__Block_byref_i_0 *)&amp;i, 0, sizeof(__Block_byref_i_0), 1024};
    void (*block1)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;i, 570425344);
    ((void (*)(__block_impl *))((__block_impl *)block1)-&gt;FuncPtr)((__block_impl *)block1);
    return 0;
}
</code></pre>

<p>从代码中我们可以看到：</p>

<ol>
<li>源码中增加一个名为 <strong>__Block_byref_i_0</strong> 的结构体，用来保存我们要 <strong>capture</strong> 并且修改的变量 <strong>i</strong>。</li>
<li><strong>main_block_impl_0</strong> 中引用的是 <strong>Block_byref_i_0</strong> 的结构体指针，这样就可以达到修改外部变量的作用。</li>
<li><strong>__Block_byref_i_0</strong> 结构体中带有 <strong>isa</strong>，说明它也是一个对象。</li>
<li>我们需要负责 <strong>Block_byref_i_0</strong> 结构体相关的内存管理，所以 <strong>main_block_desc_0</strong> 中增加了 <strong>copy</strong> 和 <strong>dispose</strong> 函数指针，对于在调用前后修改相应变量的引用计数。</li>
</ol>


<h3>NSConcreteMallocBlock 类型的block的实现</h3>

<p><strong>NSConcreteMallocBlock</strong> 类型的 <strong>block</strong> 通常不会在源码中直接出现，因为默认它是当一个 <strong>block</strong> 被 <strong>copy</strong> 的时候，才会将这个 <strong>block</strong> 复制到堆中。以下是一个 <strong>block</strong> 被 <strong>copy</strong> 时的示例代码(来自<a href="http://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/">这里</a>)，可以看到，在第8步，目标的 <strong>block</strong> 类型被修改为 <strong>_NSConcreteMallocBlock</strong>。</p>

<pre><code class="objc">static void *_Block_copy_internal(const void *arg, const int flags) {
    struct Block_layout *aBlock;
    const bool wantsOne = (WANTS_ONE &amp; flags) == WANTS_ONE;

    // 1
    if (!arg) return NULL;

    // 2
    aBlock = (struct Block_layout *)arg;

    // 3
    if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) {
        // latches on high
        latching_incr_int(&amp;aBlock-&gt;flags);
        return aBlock;
    }

    // 4
    else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) {
        return aBlock;
    }

    // 5
    struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);
    if (!result) return (void *)0;

    // 6
    memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first

    // 7
    result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed
    result-&gt;flags |= BLOCK_NEEDS_FREE | 1;

    // 8
    result-&gt;isa = _NSConcreteMallocBlock;

    // 9
    if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) {
        (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup
    }

    return result;
}
</code></pre>

<h2>变量的复制</h2>

<p>对于 <strong>block</strong> 外的变量引用，<strong>block</strong> 默认是将其复制到其数据结构中来实现访问的，如下图所示（图片来自<a href="http://rypress.com/tutorials/objective-c/blocks.html">这里</a>）：</p>

<p><img src="/images/posts/2014-03-26-a-look-inside-blocks/block-capture-1.jpg"></p>

<p>对于用 <strong>__block</strong> 修饰的外部变量引用，<strong>block</strong> 是复制其引用地址来实现访问的，如下图所示（图片来自<a href="http://rypress.com/tutorials/objective-c/blocks.html">这里</a>）：</p>

<p><img src="/images/posts/2014-03-26-a-look-inside-blocks/block-capture-2.jpg"></p>

<h2>LLVM源码</h2>

<p>在 LLVM 开源的关于 <a href="https://llvm.org/svn/llvm-project/compiler-rt/trunk/BlocksRuntime/Block_private.h"><strong>block</strong> 的实现源码</a>，其内容也和我们用 clang 改写得到的内容相似，印证了我们对于 <strong>block</strong> 内部数据结构的推测。</p>

<h2>ARC对block类型的影响</h2>

<p>在 ARC 开启的情况下，将只会有 <strong>NSConcreteGlobalBlock</strong> 和 <strong>NSConcreteMallocBlock</strong> 类型的 <strong>block</strong>。</p>

<p>原本的 <strong>NSConcreteStackBlock</strong> 的 <strong>block</strong> 会被 <strong>NSConcreteMallocBlock</strong> 类型的 <strong>block</strong> 替代。证明方式是以下代码在 XCode 中，会输出 <code>&lt;__NSMallocBlock__: 0x100109960&gt;</code>。在苹果的官方文档中也提到，当把栈中的 <strong>block</strong> 返回时，不需要调用 <strong>copy</strong> 方法了。</p>

<pre><code class="objc">#import &lt;Foundation/Foundation.h&gt;

int main(int argc, const char * argv[])
{
    @autoreleasepool {
        int i = 1024;
        void (^block1)(void) = ^{
            printf("%d\n", i);
        };
        block1();
        NSLog(@"%@", block1);
    }
    return 0;
}
</code></pre>

<p>我个人认为这么做的原因是，由于 ARC 已经能很好地处理对象的生命周期的管理，这样所有对象都放到堆上管理，对于编译器实现来说，会比较方便。</p>

<h2>参考链接</h2>

<p>希望本文能加深你对于 <strong>block</strong> 的理解。我在学习中，查阅了以下文章，一并分享给大家。祝大家玩得开心～</p>

<ul>
<li><p><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-1">A look inside blocks: Episode 1</a></p></li>
<li><p><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-2/">A look inside blocks: Episode 2</a></p></li>
<li><p><a href="http://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/">A look inside blocks: Episode 3</a></p></li>
<li><p><a href="http://www.cnblogs.com/biosli/archive/2013/05/29/iOS_Objective-C_Block.html">对Objective-C中Block的追探</a></p></li>
<li><p><a href="https://llvm.org/svn/llvm-project/compiler-rt/trunk/BlocksRuntime/Block_private.h">LLVM中block实现源码</a></p></li>
<li><p><a href="http://blog.parse.com/2013/02/05/objective-c-blocks-quiz/">objective-c-blocks-quiz</a></p></li>
<li><p><a href="http://rypress.com/tutorials/objective-c/blocks.html">Blocks</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C对象模型及应用]]></title>
    <link href="http://orinchen.github.io/blog/2014/03/20/objective-c-object-model/"/>
    <updated>2014-03-20T10:43:32+08:00</updated>
    <id>http://orinchen.github.io/blog/2014/03/20/objective-c-object-model</id>
    <content type="html"><![CDATA[<p>本文转载自:<a href="http://blog.devtang.com/blog/2013/10/15/objective-c-object-model/">唐巧的技术博客</a></p>

<h2>前言</h2>

<p>本文主要介绍 Objective-C 对象模型的实现细节，以及 Objective-C 语言对象模型中对 <strong>isa swizzling</strong> 和 <strong>method swizzling</strong> 的支持。希望本文能加深你对 Objective-C 对象的理解。</p>

<!--more-->


<h2>ISA指针</h2>

<p>Objective-C 是一门面向对象的编程语言。每一个对象都是一个类的实例。在 Objective-C 语言的内部，每一个对象都有一个名为 <strong>isa</strong> 的指针，指向该对象的类。每一个类描述了一系列它的实例的特点，包括成员变量的列表，成员函数的列表等。每一个对象都可以接受消息，而对象能够接收的消息列表是保存在它所对应的类中。</p>

<p>在 XCode 中按 <em>Shift + Command + O</em>, 然后输入 NSObject.h 和 objc.h，可以打开 <code>NSObject</code> 的定义头文件，通过头文件我们可以看到，<code>NSObject</code> 就是一个包含 <strong>isa</strong> 指针的结构体，如下图所示：</p>

<p><img src="/images/posts/2014-03-20-objective-c-object-model/class-nsobject-isa.jpg"></p>

<p><img src="/images/posts/2014-03-20-objective-c-object-model/class-objc-object-isa.jpg"></p>

<p>按照面向对象语言的设计原则，所有事物都应该是对象（严格来说 Objective-C 并没有完全做到这一点，因为它有象 int, double 这样的简单变量类型）。在 Objective-C 语言中，每一个类实际上也是一个对象。每一个类也有一个名为 <strong>isa</strong> 的指针。每一个类也可以接受消息，例如 <code>[NSObject alloc]</code>，就是向 NSObject 这个类发送名为 <code>alloc</code> 消息。</p>

<p>在 XCode 中按 <em>Shift + Command + O</em>, 然后输入 runtime.h，可以打开 Class 的定义头文件，通过头文件我们可以看到，Class 也是一个包含 <strong>isa</strong> 指针的结构体，如下图所示。（图中除了 <strong>isa</strong> 外还有其它成员变量，但那是为了兼容非2.0版的 Objective-C 的遗留逻辑，大家可以忽略它。）</p>

<p><img src="/images/posts/2014-03-20-objective-c-object-model/class-objc-class-isa.jpg"></p>

<p>因为类也是一个对象，那它也必须是另一个类的实列，这个类就是元类(<strong>metaclass</strong>)。元类保存了类方法的列表。当一个类方法被调用时，元类会首先查找它本身是否有该类方法的实现，如果没有，则该元类会向它的父类查找该方法，直到一直找到继承链的头。</p>

<p>元类(<strong>metaclass</strong>)也是一个对象，那么元类的 <strong>isa</strong> 指针又指向哪里呢？为了设计上的完整，所有的元类的 <strong>isa</strong> 指针都会指向一个根元类(<strong>root metaclass</strong>)。根元类(<strong>root metaclass</strong>)本身的 <strong>isa</strong> 指针指向自己，这样就行成了一个闭环。上面提到，一个对象能够接收的消息列表是保存在它所对应的类中的。在实际编程中，我们几乎不会遇到向元类发消息的情况，那它的 <strong>isa</strong> 指针在实际上很少用到。不过这么设计保证了面向对象的干净，即所有事物都是对象，都有 <strong>isa</strong> 指针。</p>

<p>我们再来看看继承关系，由于类方法的定义是保存在元类(<strong>metaclass</strong>)中，而方法调用的规则是：如果该类没有一个方法的实现，则向它的父类继续查找。所以，为了保证父类的类方法可以在子类中可以被调用，所以子类的元类会继承父类的元类，换而言之，类对象和元类对象有着同样的继承关系。</p>

<p>我很想把关系说清楚一些，但是这块儿确实有点绕，下面这张图或许能够让大家对 <strong>isa</strong>和继承的关系清楚一些（该图片来自<a href="http://www.sealiesoftware.com/blog/class%20diagram.pdf">这里</a>）:</p>

<p><img src="/images/posts/2014-03-20-objective-c-object-model/class-diagram.jpg"></p>

<p>该图中，最让人困惑的莫过于 <strong>Root Class</strong> 了。在实现中，<strong>Root Class</strong> 是指 <strong>NSObject</strong>，我们可以从图中看出：</p>

<ol>
<li>NSObject 类包括它的对象实例方法。</li>
<li>NSObject 的元类包括它的类方法，例如 alloc 方法。</li>
<li>NSObject 的元类继承自 NSObject 类。</li>
<li>一个 NSObject 的类中的方法同时也会被 NSObject 的子类在查找方法时找到。</li>
</ol>


<h2>类的成员变量</h2>

<p>如果把类的实例看成一个 <strong>C</strong> 语言的结构体（<strong>struct</strong>），上面说的 <strong>isa</strong> 指针就是这个结构体的第一个成员变量，而类的其它成员变量依次排列在结构体中。排列顺序如下图所示（图片来自《iOS 6 Programming Pushing the Limits》）：</p>

<p><img src="/images/posts/2014-03-20-objective-c-object-model/class-member.jpg"></p>

<p>为了验证该说法，我们在 XCode 中新建一个工程，在 main.m 中运行如下代码：</p>

<pre><code class="objc">#import &lt;UIKit/UIKit.h&gt;

@interface Father : NSObject {
    int _father;
}

@end

@implementation Father

@end

@interface Child : Father {
    int _child;
}

@end

@implementation Child

@end

int main(int argc, char * argv[])
{
  Child * child = [[Child alloc] init];
  @autoreleasepool {
      // ...
  }
}
</code></pre>

<p>我们将断点下在 <code>@autoreleasepool</code> 处，然后在 <strong>Console</strong> 中输入 <code>p *child</code>,则可以看到 Xcode 输出如下内容，这与我们上面的说法一致。</p>

<pre><code>(lldb) p *child
(Child) $0 = {
  (Father) Father = {
    (NSObject) NSObject = {
      (Class) isa = Child
    }
    (int) _father = 0
  }
  (int) _child = 0
}
</code></pre>

<h2>可变与不可变</h2>

<p>因为对象在内存中的排布可以看成一个结构体，该结构体的大小并不能动态变化。所以无法在运行时动态给对象增加成员变量。</p>

<p>相对的，对象的方法定义都保存在类的可变区域中。Objective-C 2.0 并未在头文件中将实现暴露出来，但在 Objective-C 1.0 中，我们可以看到方法的定义列表是一个名为 <strong>methodLists</strong> 的指针的指针（如下图所示）。通过修改该指针指向的指针的值，就可以实现动态地为某一个类增加成员方法。这也是 <strong>Category</strong> 实现的原理。同时也说明了为什么 <strong>Category</strong> 只可为对象增加成员方法，却不能增加成员变量。</p>

<p><img src="/images/posts/2014-03-20-objective-c-object-model/class-objc-class-isa.jpg"></p>

<p>需要特别说明一下，通过 <code>objc_setAssociatedObject</code> 和 <code>objc_getAssociatedObject</code> 方法可以变相地给对象增加成员变量，但由于实现机制不一样，所以并不是真正改变了对象的内存结构。</p>

<p>除了对象的方法可以动态修改，因为 <strong>isa</strong> 本身也只是一个指针，所以我们也可以在运行时动态地修改 <strong>isa</strong> 指针的值，达到替换对象整个行为的目的。不过该应用场景较少。</p>

<h2>系统相关API及应用</h2>

<h3>isa swizzling 的应用</h3>

<p>系统提供的 <strong>KVO</strong> 的实现，就利用了动态地修改 <strong>isa</strong> 指针的值的技术。在苹果的文档中可以看到如下描述：</p>

<blockquote><p>Key-Value Observing Implementation Details</p>

<p>Automatic key-value observing is implemented using a technique called isa-swizzling.</p>

<p>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p>

<p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p>

<p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p></blockquote>

<h3>Method Swizzling API说明</h3>

<p>Objective-C 提供了以下 API 来动态替换类方法或实例方法的实现：</p>

<ul>
<li><code>class_replaceMethod</code> 替换类方法的定义</li>
<li><code>method_exchangeImplementations</code> 交换2个方法的实现</li>
<li><code>method_setImplementation</code> 设置1个方法的实现</li>
</ul>


<p>这 3 个方法有一些细微的差别，给大家介绍如下：</p>

<ul>
<li><code>class_replaceMethod</code> 在苹果的文档（如下图所示）中能看到，它有两种不同的行为。当类中没有想替换的原方法时，该方法会调用 <code>class_addMethod</code> 来为该类增加一个新方法，也因为如此，<code>class_replaceMethod</code> 在调用时需要传入 <code>types</code> 参数，而 <code>method_exchangeImplementations</code> 和 <code>method_setImplementation</code> 却不需要。</li>
</ul>


<p><img src="/images/posts/2014-03-20-objective-c-object-model/class-replace-method.jpg"></p>

<ul>
<li><code>method_exchangeImplementations</code> 的内部实现其实是调用了2次 <code>method_setImplementation</code> 方法，从苹果的文档中能清晰地了解到（如下图所示）</li>
</ul>


<p><img src="/images/posts/2014-03-20-objective-c-object-model/class-method-exchange-imp.jpg"></p>

<p>从以上的区别我们可以总结出这3个API的使用场景:</p>

<ul>
<li><code>class_replaceMethod</code>, 当需要替换的方法可能有不存在的情况时，可以考虑使用该方法。</li>
<li><code>method_exchangeImplementations</code>，当需要交换2个方法的实现时使用。</li>
<li><code>method_setImplementation</code> 最简单的用法，当仅仅需要为一个方法设置其实现方式时使用。</li>
</ul>


<h2>使用示例</h2>

<p>我们在开发猿题库客户端的笔记功能时，需要使用系统的 <code>UIImagePickerController</code>。但是，我们发现，在 iOS6.0.2 系统下，系统提供的 <code>UIImagePickerController</code> 在 iPad 横屏下有转屏的 Bug，造成其方向错误。具体的 Bug 详情可以见<a href="http://stackoverflow.com/questions/12522491/crash-on-presenting-uiimagepickercontroller-under-ios-6-0">这里</a>。</p>

<p>为了修复该 Bug，我们需要替换 <code>UIImagePickerController</code> 的如下2个方法</p>

<pre><code class="objc">
- (BOOL)shouldAutorotate;
- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation;
</code></pre>

<p>我们先实现了一个名为 <code>ImagePickerReplaceMethodsHolder</code> 的类，用于定义替换后的方法和实现。如下所示：</p>

<pre><code class="objc">// ImagePickerReplaceMethodsHolder.h
@interface ImagePickerReplaceMethodsHolder : NSObject

- (BOOL)shouldAutorotate;
- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation;

@end

// ImagePickerReplaceMethodsHolder.m
@implementation ImagePickerReplaceMethodsHolder

- (BOOL)shouldAutorotate {
    return NO;
}

- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation {
    return UIInterfaceOrientationPortrait;
}


@end
</code></pre>

<p>然后，我们在调用处，判断当前的 iOS 版本，对于[iOS6.0, iOS6.1)之间的版本，我们将 <code>UIImagePickerController</code> 的有问题的方法替换。具体代码如下：</p>

<pre><code class="objc">#define SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v)  ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedAscending)
#define SYSTEM_VERSION_LESS_THAN(v)                 ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedAscending)

+ (void)load {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        [self hackForImagePicker];
    });
}

+ (void)hackForImagePicker {
    // fix bug of image picker under iOS 6.0
    // http://stackoverflow.com/questions/12522491/crash-on-presenting-uiimagepickercontroller-under-ios-6-0
    if (SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(@"6.0")
        &amp;&amp; SYSTEM_VERSION_LESS_THAN(@"6.1")) {
        Method oldMethod1 = class_getInstanceMethod([UIImagePickerController class], @selector(shouldAutorotate));
        Method newMethod1 = class_getInstanceMethod([ImagePickerReplaceMethodsHolder class], @selector(shouldAutorotate));
        method_setImplementation(oldMethod1, method_getImplementation(newMethod1));

        Method oldMethod2 = class_getInstanceMethod([UIImagePickerController class], @selector(preferredInterfaceOrientationForPresentation));
        Method newMethod2 = class_getInstanceMethod([ImagePickerReplaceMethodsHolder class], @selector(preferredInterfaceOrientationForPresentation));
        method_setImplementation(oldMethod2, method_getImplementation(newMethod2));
    }
}
</code></pre>

<p>通过如上代码，我们就针对 iOS 特定版本的有问题的系统库函数打了 Patch，使问题得到解决。</p>

<h2>开源界的使用</h2>

<p>有少量不明真相的同学以为苹果在审核时会拒绝 App 使用以上 API，这其实是对苹果的误解。使用如上 API 是安全的。另外，开源界也对以上方法都适当的使用。例如：</p>

<ul>
<li><p>著名的网络库 <strong>AFNetworking</strong>。<strong>AFNetworking</strong> 网络库(v1.x版本)使用了 <code>class_replaceMethod</code> 方法（AFHTTPRequestOperation.m文件第105行）</p></li>
<li><p>Nimbus。Nimbus 是著名的工具类库，它在其 core 模块中提供了 NIRuntimeClassModifications.h文件，用于提供上述 API 的封装。</p></li>
<li><p>国内的大众点评 iOS 客户端。该客户端使用了他们自己开发的基于 Wax 修改而来的 <a href="https://github.com/mmin18/WaxPatch">WaxPatch</a>，WaxPatch 可以实现通过服务器更新来动态修改客户端的逻辑。而 WaxPatch 主要是修改了 Wax 中的 wax_instance.m文件，在其中加入了 <code>class_replaceMethod</code> 来替换原始实现，从而实现修改客户端的原有行为。</p></li>
</ul>


<h2>总结</h2>

<p>通过本文，我们了解到了 Objective-C 语言的对象模型，以及 Objective-C 语言对象模型中对 <strong>isa swizzling</strong> 和 <strong>method swizzling</strong> 的支持。本文也通过具体的实例代码和开源项目，让我们对该对象模型提供的动态性有了更加深刻的认识。</p>

<h2>后记</h2>

<p>文章发表后，一些同行指出在 ARM64 的 CP U下，<strong>isa</strong> 的内部结构有变化。这点我是知道的，不过希望以后再撰文讨论。感兴趣的同学可以查看苹果今年WWDC2013的视频：《Session 404 Advanced in Objective-C》。</p>

<h2>参考链接</h2>

<ul>
<li><p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html</a></p></li>
<li><p><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html</a></p></li>
<li><p><a href="http://www.devalot.com/articles/2011/11/objc-object-model.html">http://www.devalot.com/articles/2011/11/objc-object-model.html</a></p></li>
<li><p><a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html">http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html</a></p></li>
<li><p><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html</a></p></li>
<li><p><a href="http://wwwmain.gnustep.org/resources/downloads.php">gunstep的实现源码</a></p></li>
<li><p><a href="http://algorithm.com.au/downloads/talks/objective-c-internals/objective-c-internals.pdf">http://algorithm.com.au/downloads/talks/objective-c-internals/objective-c-internals.pdf</a></p></li>
<li><p><a href="http://opensource.apple.com/source/objc4/objc4-532/runtime/">http://opensource.apple.com/source/objc4/objc4-532/runtime/</a></p></li>
<li><p><a href="https://github.com/AFNetworking/AFNetworking">https://github.com/AFNetworking/AFNetworking</a></p></li>
<li><p><a href="https://github.com/jverkoey/nimbus">https://github.com/jverkoey/nimbus</a></p></li>
<li><p><a href="https://github.com/mmin18/WaxPatch">https://github.com/mmin18/WaxPatch</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 GCD]]></title>
    <link href="http://orinchen.github.io/blog/2014/03/15/use-gcd/"/>
    <updated>2014-03-15T10:35:36+08:00</updated>
    <id>http://orinchen.github.io/blog/2014/03/15/use-gcd</id>
    <content type="html"><![CDATA[<p>本文转载自:<a href="http://blog.devtang.com/blog/2012/02/22/use-gcd/">唐巧的技术博客</a></p>

<h2>什么是GCD</h2>

<p>Grand Central Dispatch (GCD)是 Apple 开发的一个多核编程的解决方法。该方法在 Mac OS X 10.6 雪豹中首次推出，并随后被引入到了 iOS4.0 中。GCD 是一个替代诸如 NSThread, NSOperationQueue, NSInvocationOperation 等技术的很高效和强大的技术，它看起来象就其它语言的闭包(Closure)一样，但苹果把它叫做 blocks。</p>

<!--more-->


<h2>应用举例</h2>

<p>让我们来看一个编程场景。我们要在 iPhone 上做一个下载网页的功能，该功能非常简单，就是在 iPhone 上放置一个按钮，点击该按钮时，显示一个转动的圆圈，表示正在进行下载，下载完成之后，将内容加载到界面上的一个文本控件中。</p>

<h2>不用GCD前</h2>

<p>虽然功能简单，但是我们必须把下载过程放到后台线程中，否则会阻塞UI线程显示。所以，如果不用 GCD, 我们需要写如下3个方法：</p>

<ul>
<li>someClick 方法是点击按钮后的代码，可以看到我们用 NSInvocationOperation 建了一个后台线程，并且放到 NSOperationQueue 中。后台线程执行 download 方法。</li>
<li>download 方法处理下载网页的逻辑。下载完成后用 performSelectorOnMainThread 执行download_completed 方法。</li>
<li>download_completed 进行 clear up 的工作，并把下载的内容显示到文本控件中。</li>
</ul>


<p>这3个方法的代码如下。可以看到，虽然 开始下载 –> 下载中 –> 下载完成 这3个步骤是整个功能的三步。但是它们却被切分成了3块。他们之间因为是3个方法，所以还需要传递数据参数。如果是复杂的应用，数据参数很可能就不象本例子中的 NSString 那么简单了，另外，下载可能放到 Model 的类中来做，而界面的控制放到 View Controller 层来做，这使得本来就分开的代码变得更加散落。代码的可读性大大降低。</p>

<pre><code class="objc">static NSOperationQueue * queue;

- (IBAction)someClick:(id)sender {
    self.indicator.hidden = NO;
    [self.indicator startAnimating];
    queue = [[NSOperationQueue alloc] init];
    NSInvocationOperation * op = [[[NSInvocationOperation alloc] initWithTarget:self selector:@selector(download) object:nil] autorelease];
    [queue addOperation:op];
}

- (void)download {
    NSURL * url = [NSURL URLWithString:@"http://www.youdao.com"];
    NSError * error;
    NSString * data = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error];
    if (data != nil) {
        [self performSelectorOnMainThread:@selector(download_completed:) withObject:data waitUntilDone:NO];
    } else {
        NSLog(@"error when download:%@", error);
        [queue release];
    }
}

- (void) download_completed:(NSString *) data {
    NSLog(@"call back");
    [self.indicator stopAnimating];
    self.indicator.hidden = YES;
    self.content.text = data;
    [queue release];
}
</code></pre>

<h2>使用GCD后</h2>

<p>如果使用 GCD，以上3个方法都可以放到一起，如下所示：</p>

<pre><code class="objc">// 原代码块一
self.indicator.hidden = NO;
[self.indicator startAnimating];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    // 原代码块二
    NSURL * url = [NSURL URLWithString:@"http://www.youdao.com"];
    NSError * error;
    NSString * data = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error];
    if (data != nil) {
        // 原代码块三
        dispatch_async(dispatch_get_main_queue(), ^{
            [self.indicator stopAnimating];
            self.indicator.hidden = YES;
            self.content.text = data;
        });
    } else {
        NSLog(@"error when download:%@", error);
    }
});
</code></pre>

<p>首先我们可以看到，代码变短了。因为少了原来3个方法的定义，也少了相互之间需要传递的变量的封装。</p>

<p>另外，代码变清楚了，虽然是异步的代码，但是它们被 GCD 合理的整合在一起，逻辑非常清晰。如果应用上 MVC 模式，我们也可以将 View Controller 层的回调函数用 GCD 的方式传递给 Modal 层，这相比以前用 @selector 的方式，代码的逻辑关系会更加清楚。</p>

<h2>GCD的定义</h2>

<p>简单 GCD 的定义有点象函数指针，差别是用 ^ 替代了函数指针的 * 号，如下所示：</p>

<pre><code class="objc">// 申明变量
 (void) (^loggerBlock)(void);
 // 定义

 loggerBlock = ^{
      NSLog(@"Hello world");
 };
 // 调用
 loggerBlock();
</code></pre>

<p>但是大多数时候，我们通常使用内联的方式来定义它，即将它的程序块写在调用的函数里面，例如这样：</p>

<pre><code class="objc">dispatch_async(dispatch_get_global_queue(0, 0), ^{
      // something
 });
</code></pre>

<p>从上面大家可以看出，block 有如下特点：</p>

<ol>
<li>程序块可以在代码中以内联的方式来定义。</li>
<li>程序块可以访问在创建它的范围内的可用的变量。</li>
</ol>


<h2>系统提供的 dispatch 方法</h2>

<p>为了方便地使用 GCD，苹果提供了一些方法方便我们将 block 放在主线程或后台线程执行，或者延后执行。使用的例子如下：</p>

<pre><code class="objc">//  后台执行：
 dispatch_async(dispatch_get_global_queue(0, 0), ^{
      // something
 });
 // 主线程执行：
 dispatch_async(dispatch_get_main_queue(), ^{
      // something
 });
 // 一次性执行：
 static dispatch_once_t onceToken;
 dispatch_once(&amp;onceToken, ^{
     // code to be executed once
 });
 // 延迟2秒执行：
 double delayInSeconds = 2.0;
 dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC);
 dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
     // code to be executed on the main queue after delay
 });
</code></pre>

<p>dispatch_queue_t 也可以自己定义，如要要自定义 queue，可以用 dispatch_queue_create 方法，示例如下：</p>

<pre><code class="objc">dispatch_queue_t urls_queue = dispatch_queue_create("blog.devtang.com", NULL);
dispatch_async(urls_queue, ^{
     // your code
});
dispatch_release(urls_queue);
</code></pre>

<p>另外，GCD 还有一些高级用法，例如让后台2个线程并行执行，然后等2个线程都结束后，再汇总执行结果。这个可以用 dispatch_group, dispatch_group_async 和 dispatch_group_notify 来实现，示例如下：</p>

<pre><code class="objc">dispatch_group_t group = dispatch_group_create();
 dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{
      // 并行执行的线程一
 });
 dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{
      // 并行执行的线程二
 });
 dispatch_group_notify(group, dispatch_get_global_queue(0,0), ^{
      // 汇总结果
 });
</code></pre>

<h2>修改block之外的变量</h2>

<p>默认情况下，在程序块中访问的外部变量是复制过去的，即写操作不对原变量生效。但是你可以加上 __block 来让其写操作生效，示例代码如下：</p>

<pre><code class="objc">__block int a = 0;
 void  (^foo)(void) = ^{
      a = 1;
 }
 foo();
 // 这里，a的值被修改为1
</code></pre>

<h2>后台运行</h2>

<p>使用 block 的另一个用处是可以让程序在后台较长久的运行。在以前，当 app 被按 home 键退出后，app 仅有最多5秒钟的时候做一些保存或清理资源的工作。但是应用可以调用UIApplication 的 beginBackgroundTaskWithExpirationHandler 方法，让app最多有 10 分钟的时间在后台长久运行。这个时间可以用来做清理本地缓存，发送统计数据等工作。</p>

<p>让程序在后台长久运行的示例代码如下：</p>

<pre><code class="objc">// AppDelegate.h文件
@property (assign, nonatomic) UIBackgroundTaskIdentifier backgroundUpdateTask;

// AppDelegate.m文件
- (void)applicationDidEnterBackground:(UIApplication *)application
{
    [self beingBackgroundUpdateTask];
    // 在这里加上你需要长久运行的代码
    [self endBackgroundUpdateTask];
}

- (void)beingBackgroundUpdateTask
{
    self.backgroundUpdateTask = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^{
        [self endBackgroundUpdateTask];
    }];
}

- (void)endBackgroundUpdateTask
{
    [[UIApplication sharedApplication] endBackgroundTask: self.backgroundUpdateTask];
    self.backgroundUpdateTask = UIBackgroundTaskInvalid;
}
</code></pre>

<h2>总结</h2>

<p>总体来说，GCD 能够极大地方便开发者进行多线程编程。大家应该尽量使用 GCD 来处理后台线程和 UI 线程的交互。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在iOS地图上高效的显示大量数据]]></title>
    <link href="http://orinchen.github.io/blog/2013/12/28/how-to-handle-large-amounts-of-data-on-maps/"/>
    <updated>2013-12-28T16:19:52+08:00</updated>
    <id>http://orinchen.github.io/blog/2013/12/28/how-to-handle-large-amounts-of-data-on-maps</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://www.cocoachina.com/bbs/u.php?action=show&amp;uid=178143">崩月姐姐</a> 翻译自 <a href="http://robots.thoughtbot.com/how-to-handle-large-amounts-of-data-on-maps/">How To Efficiently Display Large Amounts of Data on iOS Maps</a></p>

<p>如何在iOS地图上以用户可以理解并乐于接受的方式来处理和显示大量数据。这个教程将会给大家进行示例说明。</p>

<p>我们要开发一款iOS的app应用，这个应用包含有<em>87000</em>个旅馆的信息，每个旅馆的信息中包括有一个坐标值，一个旅馆名跟一个电话号码。这款app可以在用户拖动、放大缩小地图时更新旅馆数据，而不需要用户重新进行搜索。</p>

<p>为了达到这个目的，我们需要构造一个可快速检索的数据结构。<em>C</em>语言的性能高，所以我们用C语言来构造这个数据结构。为了确保大量的数据不会让用户感到迷惑，所以我们还需要想出一个合并数据的解决方案。最后，为了更好的适应市场，我们需要把app做的更完善一些。</p>

<p>完成这个教学后，你将学到这款app的所有核心内容。</p>

<!--more-->


<p><img src="/images/posts/2013-12-28-how-to-handle-large-amounts-of-data-on-maps/4673_131216112620_1.gif"></p>

<h2>数据结构</h2>

<p>首先我们先来分析下数据，搞清我们要如何处理数据。旅馆数据中包含了一系列的坐标点(包括纬度和经度)，我们需要根据这些坐标点在地图上进行标注。地图可以任意的拖动并放大缩小，所以我们不需要把所有的点都全部绘制出来，我们只需要绘制可以显示在屏幕上的点。核心问题是：我们需要查询出显示在屏幕上的所有的点，所以我们要想出一个查找算法，查找存在于一个矩形范围内的所有点。</p>

<p>一个简单的解决方式就是遍历所有的点，然后判断<em>(xMin&lt;=x&lt;=xMax &amp;&amp; yMin&lt;=y&lt;=yMax)</em>，很不幸，这是一个复杂度为<em>O(N)</em>的算法，显然不适合我们的情况。</p>

<p>这儿有个更好的解决方法，就是我们可以利用对称性来减少我们的查询范围。那么如何能通过查询的每一次的迭代来减少查询的范围呢？我们可以在每个区域内都加索引，这样可以有效减少查询的范围。这种区域索引的方式可以用四叉树来实现，查询复杂度为<em>O(H)</em>(H是查询的那个点所在的树的高度)</p>

<h2>四叉树</h2>

<p>四叉树是一个数据结构，由一系列的结点(node)构成。每个结点包含一个桶(bucket)跟一个包围框(boundingbox)。每个桶里面有一系列的点(point)。如果一个点包含在一个外包围框A中，就会被添加到A所在结点的桶(bucket)中。一旦这个结点的桶满了，这个结点就会分裂成四个子结点，每个子节点的包围框分别是当前结点包围框的1/4。分裂之后那些本来要放到当前结点桶中的点就都会放到子容器的桶中。</p>

<p>那么我们该如何来对四叉树进行编码呢？</p>

<p>我们先来定义基本的结构：</p>

<pre><code class="obj-c">typedef struct TBQuadTreeNodeData { 
    double x; 
    double y; 
    void* data; 
} TBQuadTreeNodeData; 
TBQuadTreeNodeData TBQuadTreeNodeDataMake(double x, double y, void* data); 

typedef struct TBBoundingBox { 
    double x0; double y0; 
    double xf; double yf; 
} TBBoundingBox; 
TBBoundingBox TBBoundingBoxMake(double x0, double y0, double xf, double yf); 

typedef struct quadTreeNode { 
    struct quadTreeNode* northWest; 
    struct quadTreeNode* northEast; 
    struct quadTreeNode* southWest; 
    struct quadTreeNode* southEast; 
    TBBoundingBox boundingBox; 
    int bucketCapacity; 
    TBQuadTreeNodeData *points; 
    int count; 
} TBQuadTreeNode; 
TBQuadTreeNode* TBQuadTreeNodeMake(TBBoundingBox boundary, int bucketCapacity); 
</code></pre>

<p><code>TBQuadTreeNodeData</code>结构包含了坐标点（纬度，经度）。<code>void* data</code>是一个普通的指针，用来存储我们需要的其他信息，如旅馆名跟电话号码。<code>TBBoundingBox</code>代表一个用于范围查询的长方形，也就是之前谈到<em>(xMin&lt;=x&lt;=xMax &amp;&amp; yMin&lt;=y&lt;=yMax)</em>查询的那个长方形。左上角是<em>(xMin,yMin)</em>，右下角是<em>(xMax,yMax)</em>。</p>

<p>最后，我们看下<code>TBQuadTreeNode</code>结构，这个结构包含了四个指针，每个指针分别指向这个结点的四个子节点。它还有一个外包围框和一个数组（数组中就是那个包含一系列坐标点的桶）。</p>

<p>在我们建立完四叉树的同时，空间上的索引也就同时形成了。这是生成四叉树的演示动画。</p>

<p><img src="/images/posts/2013-12-28-how-to-handle-large-amounts-of-data-on-maps/4673_131216113026_1.gif"></p>

<p>下面的代码准确描述了以上动画的过程：</p>

<pre><code class="obj-c">void TBQuadTreeNodeSubdivide(TBQuadTreeNode* node) 
{ 
    TBBoundingBox box = node-&gt;boundingBox; 

    double xMid = (box.xf + box.x0) / 2.0; 
    double yMid = (box.yf + box.y0) / 2.0; 

    TBBoundingBox northWest = TBBoundingBoxMake(box.x0, box.y0, xMid, yMid); 
    node-&gt;northWest = TBQuadTreeNodeMake(northWest, node-&gt;bucketCapacity); 

    TBBoundingBox northEast = TBBoundingBoxMake(xMid, box.y0, box.xf, yMid); 
    node-&gt;northEast = TBQuadTreeNodeMake(northEast, node-&gt;bucketCapacity); 

    TBBoundingBox southWest = TBBoundingBoxMake(box.x0, yMid, xMid, box.yf); 
    node-&gt;southWest = TBQuadTreeNodeMake(southWest, node-&gt;bucketCapacity); 

    TBBoundingBox southEast = TBBoundingBoxMake(xMid, yMid, box.xf, box.yf); 
    node-&gt;southEast = TBQuadTreeNodeMake(southEast, node-&gt;bucketCapacity); 
} 

bool TBQuadTreeNodeInsertData(TBQuadTreeNode* node, TBQuadTreeNodeData data) 
{ 
    // Bail if our coordinate is not in the boundingBox 
    if (!TBBoundingBoxContainsData(node-&gt;boundingBox, data)) { 
        return false; 
    } 

    // Add the coordinate to the points array 
    if (node-&gt;count &lt; node-&gt;bucketCapacity) { 
        node-&gt;points[node-&gt;count++] = data; 
        return true; 
    } 

    // Check to see if the current node is a leaf, if it is, split 
    if (node-&gt;northWest == NULL) { 
        TBQuadTreeNodeSubdivide(node); 
    } 

    // Traverse the tree 
    if (TBQuadTreeNodeInsertData(node-&gt;northWest, data)) return true; 
    if (TBQuadTreeNodeInsertData(node-&gt;northEast, data)) return true; 
    if (TBQuadTreeNodeInsertData(node-&gt;southWest, data)) return true; 
    if (TBQuadTreeNodeInsertData(node-&gt;southEast, data)) return true; 

    return false; 
} 
</code></pre>

<p>现在我们已经完成了四叉树的构造，我们还需要在四叉树上进行区域范围查询并返回<code>TBQuadTreeNodeData</code>结构。以下是区域范围查询的演示动画，在浅蓝区域内的是所有的标注点。当标注点被查询到在指定的区域范围内，则会被标注为绿色。</p>

<p><img src="/images/posts/2013-12-28-how-to-handle-large-amounts-of-data-on-maps/4673_131216180218_1.gif"></p>

<p>以下是查询代码：</p>

<pre><code class="obj-c">typedef void(^TBDataReturnBlock)(TBQuadTreeNodeData data); 

void TBQuadTreeGatherDataInRange(TBQuadTreeNode* node, TBBoundingBox range, TBDataReturnBlock block) 
{ 
    // If range is not contained in the node's boundingBox then bail 
    if (!TBBoundingBoxIntersectsBoundingBox(node-&gt;boundingBox, range)) { 
        return; 
    } 

    for (int i = 0; i &lt; node-&gt;count; i++) { 
        // Gather points contained in range 
        if (TBBoundingBoxContainsData(range, node-&gt;points[i])) { 
            block(node-&gt;points[i]); 
        } 
    } 

    // Bail if node is leaf 
    if (node-&gt;northWest == NULL) { 
        return; 
    } 

    // Otherwise traverse down the tree 
    TBQuadTreeGatherDataInRange(node-&gt;northWest, range, block); 
    TBQuadTreeGatherDataInRange(node-&gt;northEast, range, block); 
    TBQuadTreeGatherDataInRange(node-&gt;southWest, range, block); 
    TBQuadTreeGatherDataInRange(node-&gt;southEast, range, block); 
} 
</code></pre>

<p>用四叉树这种结构可以进行快速的查询。在一个包含成百上千条数据的数据库中，可以以<em>60fps</em>的速度查询上百条数据。</p>

<h2>用旅馆数据来填充四叉树</h2>

<p>旅馆的数据来自于<a href="http://poiplaza.com/">POIplaza</a>这个网站，而且已经格式化成csv文件。我们要从硬盘中读取出数据并对数据进行转换，最后用数据来填充四叉树。</p>

<p>创建四叉树的代码在<code>TBCoordinateQuadTree</code>类中：</p>

<pre><code class="obj-c">typedef struct TBHotelInfo { 
    char* hotelName; 
    char* hotelPhoneNumber; 
} TBHotelInfo; 

TBQuadTreeNodeData TBDataFromLine(NSString *line) 
{ 
    // Example line: 
    // -80.26262, 25.81015, Everglades Motel, USA-United States, +1 305-888-8797 

    NSArray *components = [line componentsSeparatedByString:@","]; 
    double latitude = [components[1] doubleValue]; 
    double longitude = [components[0] doubleValue]; 

    TBHotelInfo* hotelInfo = malloc(sizeof(TBHotelInfo)); 

    NSString *hotelName = [components[2] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]; 
    hotelInfo-&gt;hotelName = malloc(sizeof(char) * hotelName.length + 1); 
    strncpy(hotelInfo-&gt;hotelName, [hotelName UTF8String], hotelName.length + 1); 

    NSString *hotelPhoneNumber = [[components lastObject] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]; 
    hotelInfo-&gt;hotelPhoneNumber = malloc(sizeof(char) * hotelPhoneNumber.length + 1); 
    strncpy(hotelInfo-&gt;hotelPhoneNumber, [hotelPhoneNumber UTF8String], hotelPhoneNumber.length + 1); 

    return TBQuadTreeNodeDataMake(latitude, longitude, hotelInfo); 
} 

- (void)buildTree 
{ 
    NSString *data = [NSString stringWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"USA-HotelMotel" ofType:@"csv"] encoding:NSASCIIStringEncoding error:nil]; 
    NSArray *lines = [data componentsSeparatedByString:@"\n"]; 

    NSInteger count = lines.count - 1; 

    TBQuadTreeNodeData *dataArray = malloc(sizeof(TBQuadTreeNodeData) * count); 
    for (NSInteger i = 0; i &lt; count; i++) { 
        dataArray[i] = TBDataFromLine(lines[i]); 
    } 

    TBBoundingBox world = TBBoundingBoxMake(19, -166, 72, -53); 
    _root = TBQuadTreeBuildWithData(dataArray, count, world, 4); 
} 
</code></pre>

<p>现在我们用iPhone上预加载的数据创建了一个四叉树。接下来我们将处理app的下一个部分：合并数据（clustering）。</p>

<h2>合并数据（clustering）</h2>

<p>现在我们有了一个装满旅馆数据的四叉树，可以用来解决合并数据的问题了。首先，让我们来探索下合并数据的原因。我们合并数据是因为我们不想因为数据过于庞大而使用户迷惑。实际上有很多种方式可以解决这个问题。GoogleMaps根据地图的缩放等级（zoomlevel）来显示搜索结果数据中的一部分数据。地图放的越大，就越能清晰的看到更细节的标注，直到你能看到所有有效的标注。我们将采用这种合并数据的方式，只显示出来旅馆的个数，而不在地图上显示出所有的旅馆信息。</p>

<p>最终呈现的标注是一个中心显示旅馆个数的小圆圈。实现的原理跟如何把图片缩小的原理差不多。我们先在地图上画一个格子。每个格子中包含了很多个小单元格，每个小单元格中的所有旅馆数据合并出一个标注。然后通过每个小单元格中所有旅馆的坐标值的平均值来决定合并后这个标注的坐标值。</p>

<p>这是以上处理的演示动画。</p>

<p><img src="/images/posts/2013-12-28-how-to-handle-large-amounts-of-data-on-maps/4673_131216113354_1.gif"></p>

<p>以下是代码实现过程。在<code>TBCoordinateQuadTree</code>类中添加了一个方法。</p>

<pre><code class="obj-c">- (NSArray *)clusteredAnnotationsWithinMapRect:(MKMapRect)rect withZoomScale:(double)zoomScale 
{ 
    double TBCellSize = TBCellSizeForZoomScale(zoomScale); 
    double scaleFactor = zoomScale / TBCellSize; 

    NSInteger minX = floor(MKMapRectGetMinX(rect) * scaleFactor); 
    NSInteger maxX = floor(MKMapRectGetMaxX(rect) * scaleFactor); 
    NSInteger minY = floor(MKMapRectGetMinY(rect) * scaleFactor); 
    NSInteger maxY = floor(MKMapRectGetMaxY(rect) * scaleFactor); 

    NSMutableArray *clusteredAnnotations = [[NSMutableArray alloc] init]; 

    for (NSInteger x = minX; x &lt;= maxX; x++) { 
        for (NSInteger y = minY; y &lt;= maxY; y++) { 

            MKMapRect mapRect = MKMapRectMake(x / scaleFactor, y / scaleFactor, 1.0 / scaleFactor, 1.0 / scaleFactor); 

            __block double totalX = 0; 
            __block double totalY = 0; 
            __block int count = 0; 

            TBQuadTreeGatherDataInRange(self.root, TBBoundingBoxForMapRect(mapRect), ^(TBQuadTreeNodeData data) { 
                totalX += data.x; 
                totalY += data.y; 
                count++; 
            }); 

            if (count &gt;= 1) { 
                CLLocationCoordinate2D coordinate = CLLocationCoordinate2DMake(totalX / count, totalY / count); 
                TBClusterAnnotation *annotation = [[TBClusterAnnotation alloc] initWithCoordinate:coordinate count:count]; 
                [clusteredAnnotations addObject:annotation]; 
            } 
        } 
    } 

    return [NSArray arrayWithArray:clusteredAnnotations]; 
} 
</code></pre>

<p>上面的方法在指定小单元格大小的前提下合并数据生成了最终的标注。现在我们需要做的就是把这些标注绘制到<em>MKMapView</em>上。首先我们创建一个<em>UIViewController</em>的子类，然后用<em>MKMapView</em>作为它的<em>view</em>视图。在可视区域改变的情况下，我们需要实时更新标注的显示，所以我们要实现<code>mapView:regionDidChangeAnimated:</code>的协议方法。</p>

<pre><code class="obj-c">- (void)mapView:(MKMapView *)mapView regionDidChangeAnimated:(BOOL)animated 
{ 
    [[NSOperationQueue new] addOperationWithBlock:^{ 
        double zoomScale = self.mapView.bounds.size.width / self.mapView.visibleMapRect.size.width; 
        NSArray *annotations = [self.coordinateQuadTree clusteredAnnotationsWithinMapRect:mapView.visibleMapRect withZoomScale:zoomScale]; 

        [self updateMapViewAnnotationsWithAnnotations:annotations]; 
    }]; 
}
</code></pre>

<h1>只添加必要的标注</h1>

<p>在主线程中我们期望尽可能花费较少时间来做运算，这意味着我们要尽可能的把所有内容都放到后台的线程中。为了在主线程中花费更少的时间来做计算，我们只需要绘制一些必要的标注。这可以避免用户滑动过程中感到很卡，从而保证流畅的用户体验。</p>

<p>开始之前，我们看一下下面的图片：</p>

<p><img src="/images/posts/2013-12-28-how-to-handle-large-amounts-of-data-on-maps/4673_131216113807_1.jpg"></p>

<p>左边的屏幕截图是地图进行滑动前的地图快照。这个快照中的标注就是目前mapView中的标注，我们称这个为“before集合”。</p>

<p>右边的屏幕截图是地图进行滑动后的地图快照。这个快照中的标注就是从<code>clusteredAnnotationsWithinMapRect:withZoomScale:</code>这个函数中得到的返回值。我们称这个为“after集合”。</p>

<p>我们期望保留两个快照中都存在的标注点（即重合的那些标注点），去除在“after集合”中不存在的那些标注点，同时添加那些新的标注点。</p>

<pre><code class="obj-c">- (void)updateMapViewAnnotationsWithAnnotations:(NSArray *)annotations 
{ 
    NSMutableSet *before = [NSMutableSet setWithArray:self.mapView.annotations]; 
    NSSet *after = [NSSet setWithArray:annotations]; 

    // Annotations circled in blue shared by both sets 
    NSMutableSet *toKeep = [NSMutableSet setWithSet:before]; 
    [toKeep intersectSet:after]; 

    // Annotations circled in green 
    NSMutableSet *toAdd = [NSMutableSet setWithSet:after]; 
    [toAdd minusSet:toKeep]; 

    // Annotations circled in red 
    NSMutableSet *toRemove = [NSMutableSet setWithSet:before]; 
    [toRemove minusSet:after]; 

    // These two methods must be called on the main thread 
    [[NSOperationQueue mainQueue] addOperationWithBlock:^{ 
        [self.mapView addAnnotations:[toAdd allObjects]]; 
        [self.mapView removeAnnotations:[toRemove allObjects]]; 
    }]; 
} 
</code></pre>

<p>这样我们尽可能的确保在主线程上做少量的工作，从而提升地图滑动的流畅性。</p>

<p>接下来我们来看下如何绘制标注，并且在标注上显示出来旅馆的个数。最后我们给标注加上点击事件，这样使得app从头到脚都可以表现的非常完美。</p>

<p>绘制标注
由于我们在地图上并没有完全显示出全部旅馆，所以我们需要在剩余的这些标注上表现出真实的旅馆总量。</p>

<p>首先创建一个圆形的标注，中间显示合并后的个数，也就是旅馆的真实总量。这个圆形的大小同样可以反映出合并后的个数。</p>

<p>为了实现这个需求，我们要找出一个方程式，允许我们在1到500+的数值中生成一个缩小后的数值。用这个数值来作为标注的大小。我们将用到以下的方程式。</p>

<p><img src="/images/posts/2013-12-28-how-to-handle-large-amounts-of-data-on-maps/4673_131216114009_1.png"></p>

<p>x值较低的时候f(x)增长的比较快，x在值变大的时候f(x)增长变缓慢，β值用来控制f(x)趋于1的速度。α值影响最小值（在我们的项目中，我们的最小合并值（也就是1）能占总共最大值的60%）。</p>

<pre><code class="obj-c">static CGFloat const TBScaleFactorAlpha = 0.3; 
static CGFloat const TBScaleFactorBeta = 0.4; 

CGFloat TBScaledValueForValue(CGFloat value) 
{ 
    return 1.0 / (1.0 + expf(-1 * TBScaleFactorAlpha * powf(value, TBScaleFactorBeta))); 
} 

- (void)setCount:(NSUInteger)count 
{ 
    _count = count; 

    // Our max size is (44,44) 
    CGRect newBounds = CGRectMake(0, 0, roundf(44 * TBScaledValueForValue(count)), roundf(44 * TBScaledValueForValue(count))); 
    self.frame = TBCenterRect(newBounds, self.center); 

    CGRect newLabelBounds = CGRectMake(0, 0, newBounds.size.width / 1.3, newBounds.size.height / 1.3); 
    self.countLabel.frame = TBCenterRect(newLabelBounds, TBRectCenter(newBounds)); 
    self.countLabel.text = [@(_count) stringValue]; 

    [self setNeedsDisplay]; 
} 
</code></pre>

<p>现在标注的大小已经OK了。让我们再来把这个标注做漂亮些。</p>

<pre><code class="obj-c">- (void)setupLabel 
{ 
    _countLabel = [[UILabel alloc] initWithFrame:self.frame]; 
    _countLabel.backgroundColor = [UIColor clearColor]; 
    _countLabel.textColor = [UIColor whiteColor]; 
    _countLabel.textAlignment = NSTextAlignmentCenter; 
    _countLabel.shadowColor = [UIColor colorWithWhite:0.0 alpha:0.75]; 
    _countLabel.shadowOffset = CGSizeMake(0, -1); 
    _countLabel.adjustsFontSizeToFitWidth = YES; 
    _countLabel.numberOfLines = 1; 
    _countLabel.font = [UIFont boldSystemFontOfSize:12]; 
    _countLabel.baselineAdjustment = UIBaselineAdjustmentAlignCenters; 
    [self addSubview:_countLabel]; 
} 

- (void)drawRect:(CGRect)rect 
{ 
    CGContextRef context = UIGraphicsGetCurrentContext(); 

    CGContextSetAllowsAntialiasing(context, true); 

    UIColor *outerCircleStrokeColor = [UIColor colorWithWhite:0 alpha:0.25]; 
    UIColor *innerCircleStrokeColor = [UIColor whiteColor]; 
    UIColor *innerCircleFillColor = [UIColor colorWithRed:(255.0 / 255.0) green:(95 / 255.0) blue:(42 / 255.0) alpha:1.0]; 

    CGRect circleFrame = CGRectInset(rect, 4, 4); 

    [outerCircleStrokeColor setStroke]; 
    CGContextSetLineWidth(context, 5.0); 
    CGContextStrokeEllipseInRect(context, circleFrame); 

    [innerCircleStrokeColor setStroke]; 
    CGContextSetLineWidth(context, 4); 
    CGContextStrokeEllipseInRect(context, circleFrame); 

    [innerCircleFillColor setFill]; 
    CGContextFillEllipseInRect(context, circleFrame); 
} 
</code></pre>

<h2>添加最后的touch事件</h2>

<p>目前的标注可以很好的呈现出我们的数据了，让我们最后添加一些touch事件来让我们的app用起来更有趣。</p>

<p>首先，我们需要为新添加到地图上的标注做一个动画。如果没有添加动画的话，新的标注就会在地图上突然出现，体验效果将会大打折扣。</p>

<pre><code class="obj-c">- (void)addBounceAnnimationToView:(UIView *)view 
{ 
    CAKeyframeAnimation *bounceAnimation = [CAKeyframeAnimation animationWithKeyPath:@"transform.scale"]; 

    bounceAnimation.values = @[@(0.05), @(1.1), @(0.9), @(1)]; 

    bounceAnimation.duration = 0.6; 
    NSMutableArray *timingFunctions = [[NSMutableArray alloc] init]; 
    for (NSInteger i = 0; i &lt; 4; i++) { 
        [timingFunctions addObject:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]]; 
    } 
    [bounceAnimation setTimingFunctions:timingFunctions.copy]; 
    bounceAnimation.removedOnCompletion = NO; 

    [view.layer addAnimation:bounceAnimation forKey:@"bounce"]; 
} 

- (void)mapView:(MKMapView *)mapView didAddAnnotationViews:(NSArray *)views 
{ 
    for (UIView *view in views) { 
        [self addBounceAnnimationToView:view]; 
    } 
} 
</code></pre>

<p>接下来，我们想要根据地图的缩放比例来改变在合并时的小单元格（cell）的大小。在地图进行放大时，小单元格变小。所以我们需要定义一下当前地图的缩放比例。也就是<code>scale=mapView.bounds.size.width/mapView.visibleMapRect.size.width</code>:</p>

<pre><code class="obj-c">NSInteger TBZoomScaleToZoomLevel(MKZoomScale scale) 
{ 
    double totalTilesAtMaxZoom = MKMapSizeWorld.width / 256.0; 
    NSInteger zoomLevelAtMaxZoom = log2(totalTilesAtMaxZoom); 
    NSInteger zoomLevel = MAX(0, zoomLevelAtMaxZoom + floor(log2f(scale) + 0.5)); 

    return zoomLevel; 
} 
</code></pre>

<p>我们为每个地图缩放的比例都定义一个常量。</p>

<pre><code class="obj-c">float TBCellSizeForZoomScale(MKZoomScale zoomScale) 
{ 
    NSInteger zoomLevel = TBZoomScaleToZoomLevel(zoomScale); 

    switch (zoomLevel) { 
        case 13: 
        case 14: 
        case 15: 
            return 64; 
        case 16: 
        case 17: 
        case 18: 
            return 32; 
        case 19: 
            return 16; 

        default: 
            return 88; 
    } 
} 
</code></pre>

<p>现在我们放大地图，我们将看到逐渐变小的标注，直到最后我们能看到代表每个旅馆的那个标注。</p>

<p><a href="https://github.com/thoughtbot/TBAnnotationClustering">完整源代码在这里</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[值对象]]></title>
    <link href="http://orinchen.github.io/blog/2013/12/27/value-object/"/>
    <updated>2013-12-27T12:45:00+08:00</updated>
    <id>http://orinchen.github.io/blog/2013/12/27/value-object</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://ansonzhao.com/">Anson</a> 翻译自 <a href="http://www.objc.io/issue-7/value-objects.html">Value Objects</a></p>

<p>在这篇文章中，我们将看看如何用<em>Objective-C</em>语言编写值对象。在编写时，我们将会接触到<em>Objective-C</em>中的重要协议和方法。一个值对象是一个包含一些值的对象，并且可以进行相等比较。通常值对象可以被用作模型对象。例如，考虑一个简单的<em>Person</em>对象：</p>

<!--more-->


<pre><code class="objective-c">@interface Person : NSObject

@property (nonatomic,copy) NSString* name;
@property (nonatomic,strong) NSDate* birthDate;
@property (nonatomic) NSUInteger numberOfKids;

@end
</code></pre>

<p>创建这些类型的对象是我们工作的面包和黄油（译者注：基本元素），虽然这些对象看上去很简单，但是仍然包含许多微妙之处。</p>

<p>有一件事，我们很多人硬性的认为这些对象应该是一成不变的。一旦你创建了一个<em>Person</em>对象，它不可能被改变。我们将在稍后涉及到可变性这个问题。</p>

<h2>属性</h2>

<p>首先要注意的是我们使用属性来定义一个<em>Person</em>的特征。创建属性是想当机械的：对于普通对象的属性，你设置它们为<code>nonatomic</code>和<code>strong</code>，而对于标量属性你只需要设置<code>nonatomic</code>。默认情况下，它们也是<code>assign</code>。有一个例外，对于具有可变副本的属性，你想将他们定义为<code>copy</code>。例如，<code>name</code>属性的类型是<code>NSString</code>，有可能出现的情况是，有人创建了一个<em>Person</em>对象，并指定类型为<code>NSMutableString</code>的值。然后一段时间后，他或她可能会改变这个可变的字符串。如果我们的属性是<code>strong</code>而不是<code>copy</code>，我们的<em>Person</em>对象会随之改变，这不是我们想要的。对于容器类型也是一样的，例如数组或者字典。</p>

<p>请注意，这个拷贝是浅拷贝，容器可能还包含可变对象。例如，如果你有一个<code>NSMutableArray *a</code>包含有<code>NSMutableDictionary</code>元素，则<code>[a copy]</code>将会给你一个不可变数组，但是元素是相同的<code>NSMutableDictionary</code>对象。正如我们稍后将看到的，不可变对象的拷贝是无成本的，但是它增加了引用计数。</p>

<p>在旧的代码中，你可能看不到属性，因为他们是相对近期才加入到<em>Objective-C</em>语言的。代替现有属性，有可能会看到自定义的<em>getter</em>和<em>setter</em>方法，或纯实例变量。对于现在的代码，似乎似乎大多数人都同意使用属性，这也是我们所推荐的。</p>

<h3>更多阅读</h3>

<p><a href="http://stackoverflow.com/questions/387959/nsstring-property-copy-or-retain">NSString:copy or retian</a></p>

<h2>初始化方法</h2>

<p>如果我们想要不可变对象，我们应该确保他们被创建后不能进行修改。我们可以通过添加一个初始化方法和在接口里使我们的属性只读来做到这一点。我们的接口将如下所示：</p>

<pre><code class="objective-c">@interface Person : NSObject

@property (nonatomic,copy,readonly) NSString* name;
@property (nonatomic,strong,readonly) NSDate* birthDate;
@property (nonatomic,readonly) NSUInteger numberOfKids;

- (instancetype)initWithName:(NSString*)name
                   birthDate:(NSDate*)birthDate
                numberOfKids:(NSUInteger)numberOfKids;

@end
</code></pre>

<p>然后，在我们的实现中，我们必须使我们的属性<em>readwrite</em>，从而生成实例变量：</p>

<pre><code class="objective-c">@interface Person ()

@property (nonatomic,copy) NSString* name;
@property (nonatomic,strong) NSDate* birthDate;
@property (nonatomic) NSUInteger numberOfKids;


@end

@implementation Person

- (instancetype)initWithName:(NSString*)name
                   birthDate:(NSDate*)birthDate
                numberOfKids:(NSUInteger)numberOfKids
{
    self = [super init];
    if (self) {
        self.name = name;
        self.birthDate = birthDate;
        self.numberOfKids = numberOfKids;
    }
    return self;
}

@end
</code></pre>

<p>现在我们可以构造新的<em>Person</em>对象，但不能修改它们了。这是非常有帮助的，当编写与<em>Person</em>对象工作的其他类时，我们知道我们正在工作的值不能改变。</p>

<h2>相等比较</h2>

<p>要比较是否相等，我们必须实现<code>isEqual:</code>方法。我们希望<code>isEqual:</code>返回true当且仅当所有的属性都相等。由<em>Mike Ash</em>（<a href="http://www.mikeash.com/pyblog/friday-qa-2010-06-18-implementing-equality-and-hashing.html">实现相等和散列</a>）和<em>NSHipster</em>（<a href="http://nshipster.com/equality/">相等</a>）写的两篇很好的文章解释了如何做到这点。首先，让我们写<code>isEqual:</code>：</p>

<pre><code class="objective-c">- (BOOL)isEqual:(id)obj
{
    if(![obj isKindOfClass:[Person class]]) return NO;

    Person* other = (Person*)obj;

    BOOL nameIsEqual = self.name == other.name || [self.name isEqual:other.name];
    BOOL birthDateIsEqual = self.birthDate == other.birthDate || [self.birthDate isEqual:other.birthDate];
    BOOL numberOfKidsIsEqual = self.numberOfKids == other.numberOfKids;
    return nameIsEqual &amp;&amp; birthDateIsEqual &amp;&amp; numberOfKidsIsEqual;
}
</code></pre>

<p>现在，我们检查是否我们是相同类型的类。如果不是，我们肯定不相等。然后对每个对象的属性，我们检查是否指针是相等的。<code>||</code>左侧的运算数似乎是多余的，但如果两个属性都为<code>nil</code>则返回<code>YES</code>。为了比较标量值相等像<code>NSUInteger</code>，我们可以只使用<code>==</code>。</p>

<p>有一件事值得注意：这里我们分成不同的属性到他们自己的布尔值里。在实践中，可能将它们合成一个大的条件更有意义，因为这样你直接得到惰性求值。在上面的例子中，如果名字不相等，我们就不需要检查任何其他的属性。通过把所有组合成一个<code>if</code>语句，我们直接得到优化。</p>

<p>下一步，按照<a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/isEqual:">这个文档</a>，我们需要实现一个哈希函数也是如此。Apple说：</p>

<blockquote><p>如果两个对象相等，他们必须有相同的哈希值。如果你在子类中定义了<code>isEqual:</code>，并且打算把该子类的实例放入集合中，这最后一点就特别重要了。请确保你在你的子类中也定义了哈希。</p></blockquote>

<p>首先，我们可以尝试运行下面没有实现哈希函数的代码：</p>

<pre><code class="objective-c">Person* p1 = [[Person alloc] initWithName:name birthDate:start numberOfKids:0];
Person* p2 = [[Person alloc] initWithName:name birthDate:start numberOfKids:0];
NSDictionary* dict = @{p1: @"one", p2: @"two"};
NSLog(@"%@", dict);
</code></pre>

<p>我第一次跑了上面的代码，一切都很好，在字典中有两个项目。第二次，只有一个了。事情变得非常不可预测了，所以我们照着文档说的来做了。</p>

<p>正如你可能还记得您的计算机科学课程中，写一个好的哈希函数不是很容易的。一个好的哈希函数必须是确定性的和均匀的。确定性意味着，在相同的输入下需要生成相同的哈希值。均匀表示哈希函数的结果应该均匀地将输入映射在输出范围内。你的输出越均匀，你在集合中使用这些对象的性能越好。</p>

<p>首先，为了弄清楚，让我们来看看当我们没有一个哈希函数发生了什么，我们尝试使用<em>Person</em>对象作为字典的键：</p>

<pre><code class="objective-c">NSMutableDictionary* dictionary = [NSMutableDictionary dictionary];

NSDate* start = [NSDate date];
for (int i = 0; i &lt; 50000; i++) {
    NSString* name = randomString();
    Person* p = [[Person alloc] initWithName:name birthDate:[NSDate date] numberOfKids:i++];
    [dictionary setObject:@"value" forKey:p];
}
NSLog(@"%f", [[NSDate date] timeIntervalSinceDate:start]);
</code></pre>

<p>这在我的机器上运行需要29秒。相比之下，当我们实现一个基本的哈希函数，相同的代码运行只需要0.4秒。这不是合适的基准，但也给出了一个好的迹象，为什么要实现一个适当的哈希函数是很重要的。 对于Person类，我们可以用这样的哈希函数开始：</p>

<pre><code class="objective-c">- (NSUInteger)hash
{
    return self.name.hash ^ self.birthDate.hash ^ self.numberOfKids;
}
</code></pre>

<p>这将从我们的属性中产生三个哈希值并且XOR他们。在这种情况下，对我们来说已经足够了，因为<code>NSString</code>的哈希函数对于短字符串来说很好（过去表现良好的字符串<a href="http://www.abakia.de/blog/2012/12/05/nsstring-hash-is-bad/">最多96个字符</a>，但是现在已经改变了。见<a href="http://www.opensource.apple.com/source/CF/CF-855.11/CFString.c">CFString.c</a>，寻找哈希）。对于严重的散列，你的哈希函数取决于你拥有的数据。这被<a href="http://www.opensource.apple.com/source/CF/CF-855.11/CFString.c">Mike Ash</a>的文章和<a href="http://www.burtleburtle.net/bob/hash/spooky.html">其他地方</a>所提及。</p>

<p>在哈希的<a href="https://developer.apple.com/library/mac/documentation/cocoa/Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/hash">文档</a>里，有如下的段落：</p>

<blockquote><p>如果一个可变对象被添加到使用哈希值来确定集合中对象位置的集合中，当对象在集合中，对象的哈希方法返回的值必须不能改变。因此，无论是哈希方法必须不依赖于任何对象的内部状态信息，还是当对象在集合中你必须确保该对象的内部状态信息不会改变。因此，例如，一个可变字典可以放入一个哈希表中，但是当它在那里你不能改变它。（请注意，可能很难知道给定的对象是否在一个集合中。）</p></blockquote>

<p>这是为了确保你的对象是不可变的另一个非常重要的原因。然后，你甚至不必担心这个问题了。</p>

<h3>更多阅读</h3>

<ul>
<li><a href="https://gist.github.com/steipete/6133152">A hash function for CGRect</a></li>
<li><a href="http://www.burtleburtle.net/bob/hash/doobs.html">A Hash Function for Hash Table Lookup</a></li>
<li><a href="http://www.burtleburtle.net/bob/hash/spooky.html">SpookyHash: a 128-bit noncryptographic hash</a></li>
<li><a href="http://computinglife.wordpress.com/2008/11/20/why-do-hash-functions-use-prime-numbers/">Why do hash functions use prime numbers?</a></li>
</ul>


<h2>NSCopying</h2>

<p>为了确保我们的对象是有用的，可以方便的实现<code>NSCopying</code>协议。让我们举例来说，在容器类中使用它们。对于我们类中的一个可变的变量，<code>NSCopying</code>可以被这样实现：</p>

<pre><code class="obj-c">- (id)copyWithZone:(NSZone *)zone
{
    Person* p = [[Person allocWithZone:zone] initWithName:self.name
                                                birthDate:self.birthDate
                                             numberOfKids:self.numberOfKids];
    return p;
}
</code></pre>

<p>然而，在协议文档中，他们提到另一种方式来实现<code>NSCopying</code>：</p>

<blockquote><p>当类和它的内容是不可变的，通过保留原有的实现NSCopying，而不是创建一个新的副本。</p></blockquote>

<p>因此，对于我们不可变的版本，我们只要这样做：</p>

<pre><code class="obj-c">- (id)copyWithZone:(NSZone *)zone
{
    return self;
}
</code></pre>

<h2>NSCoding</h2>

<p>如果我们要序列化我们的对象，我们可以通过实现<code>NSCoding</code>来做到这一点。该协议存在两个必需的方法：</p>

<pre><code class="obj-c">- (id)initWithCoder:(NSCoder *)decoder
- (void)encodeWithCoder:(NSCoder *)encoder
</code></pre>

<p>实现这个和实现相等方法同样简单，也比较机械：</p>

<pre><code class="obj-c">- (id)initWithCoder:(NSCoder *)aDecoder
{
    self = [super init];
    if (self) {
        self.name = [aDecoder decodeObjectForKey:@"name"];
        self.birthDate = [aDecoder decodeObjectForKey:@"birthDate"];
        self.numberOfKids = [aDecoder decodeIntegerForKey:@"numberOfKids"];
    }
    return self;
}

- (void)encodeWithCoder:(NSCoder *)aCoder
{
    [aCoder encodeObject:self.name forKey:@"name"];
    [aCoder encodeObject:self.birthDate forKey:@"birthDate"];
    [aCoder encodeInteger:self.numberOfKids forKey:@"numberOfKids"];
}
</code></pre>

<p>关于它可以从<a href="http://nshipster.com/nscoding/">NSHipster</a>和<a href="http://www.mikeash.com/pyblog/friday-qa-2013-08-30-model-serialization-with-property-lists.html">Mike Ash</a>的博客中阅读更多。顺便说一句，当处理不受信任的来源，如数据来自网络，<em>不要</em>使用<code>NSCoding</code>。因为数据可能被篡改。通过<a href="https://developer.apple.com/library/mac/documentation/security/conceptual/securecodingguide/Articles/ValidatingInput.html#//apple_ref/doc/uid/TP40007246-SW9">修改存档的数据</a>，它很可能要执行远程代码进行攻击。取而代之，使用<a href="http://nshipster.com/nssecurecoding/">NSSecureCoding</a>或像<em>JSON</em>的自定义格式。</p>

<h2>Mantle</h2>

<p>现在我们留下了一个问题：我们可以自动化它吗？事实证明，我们可以做到。一种方法是代码生成，但幸运的是有一个更好的选择：<a href="https://github.com/github/Mantle">Mantle</a>。<em>Mantle</em>使用内省(introspection)来产生<code>isEqual:</code>和哈希。此外，它提供了一些方法来帮助你创建字典，然后可以用于写入和读取JSON。当然，一般运行时这样做将不会像自己写的代码一样有效率，但在另一方面，自动执行是一个更不容易出错的过程。</p>

<h2>可变性</h2>

<p>在<em>C</em>语言和<em>Objective-C</em>语言中，可变的值是默认值。在某种程度上，它们是非常方便的，因为你可以在任何时候改变任何东西。当建立较小的系统，这应该是没有问题的。然而，正如我们许多人了解的方法，建立规模更大的系统时，事情是不可变时会相当容易。在<em>Objective-C</em>中，我们已经使用不可变对象很长时间了，并且现在其他语言也开始添加。</p>

<p>我们来看看可变对象的两个问题。一个是当你不希望它改变时它们可能会改变，另一个是在多线程环境中使用可变对象。</p>

<h3>意想不到的变化</h3>

<p>假设我们有一个表视图控制器，其中有一个<em>People</em>属性：</p>

<pre><code class="obj-c">@interface ViewController : UITableViewController

@property (nonatomic, strong) NSArray* people;

@end
</code></pre>

<p>而在我们的实现里，我们只是映射每个数组元素到一个单元格：</p>

<pre><code class="obj-c">- (NSInteger)numberOfSectionsInTableView:(UITableView*)tableView
{
    return 1;
}

- (NSInteger)tableView:(UITableView*)tableView numberOfRowsInSection:(NSInteger)section
{
    return self.people.count;
}
</code></pre>

<p>现在，在设置了以上视图控制器的代码中，我们可能有这样的代码：</p>

<pre><code class="obj-c">self.items = [NSMutableArray array];
[self loadItems]; // Add 100 items to the array
tableVC.people = self.items;
[self.navigationController pushViewController:tableVC animated:YES];
</code></pre>

<p>表视图将开始调用方法，如<code>tableView:numberOfRowsInSection:</code>，开始一切都很好，但是假设在某些时候，我们执行以下操作</p>

<pre><code class="obj-c">[self.items removeObjectAtIndex:1];
</code></pre>

<p>这改变了我们的<em>items</em>数组，但是它也改变了我们表视图控制器里的<em>People</em>数组。如果我们这样做而没有和表视图控制器有任何进一步的沟通，表视图将仍然认为有100个项目，而我们的数组只包含99个。不好的事情将会发生。取而代之，我们应该做的是以<code>copy</code>声明我们的属性：</p>

<pre><code class="obj-c">@interface ViewController : UITableViewController

@property (nonatomic, copy) NSArray* items;

@end
</code></pre>

<p>现在，无论什么时候我们分配一个可变的数组给<em>items</em>，一个不可变的副本将会创建。如果我们分配一个常规（不可变）的数组的值，拷贝操作是无害的，它仅仅增加了引用计数。</p>

<h3>多线程</h3>

<p>假设我们有一个可变对象，<em>Account</em>，代表一个银行账户，它有一个方法<code>transfer:to:</code>：</p>

<pre><code class="obj-c">- (void)transfer:(double)amount to:(Account*)otherAccount
{
    self.balance = self.balance - amount;
    otherAccount.balance = otherAccount.balance + amount;
}
</code></pre>

<p>多线程的代码可以在许多方面产生错误。例如，如果线程A读取<code>self.balance</code>，线程B可能会在线程A继续之前修改它。对于所有涉及到的危险的一个很好的解释，请参阅我们的<a href="http://www.objc.io/issue-2/">第二个问题</a>。</p>

<p>如果我们将它替换为不可变对象，事情就容易多了。我们不能对其进行修改，这迫使我们在一个完全不同的层次上提供可变性，产生更简单的代码。</p>

<h3>缓存</h3>

<p>另一件事，不可变性可以帮助的是在缓存值的时候。例如，假设你已经解析了一个<em>markdown</em>文档为一个包含所有不同元素节点的树形结构。如果你想生成的另外的<em>HTML</em>，你可以缓存这个值，因为你知道没有任何子节点会改变。如果你有可变对象，你则需要每次从零开始生成<em>HTML</em>，或构建优化并观察每一个单独的对象。和不变性相比，你不必担心无效的缓存。当然，这可能会带来性能损失。在几乎所有情况下，然而，简单将超过在性能上的略有下降。</p>

<h3>在其他语言里的不可变性</h3>

<p>不可变对象是灵感来自于像<a href="http://www.haskell.org/haskellwiki/Haskell">Haskell</a>的函数式编程语言的概念之一。在<em>Haskell</em>中，值默认是不可变的。<em>Haskell</em>程序通常有一个<a href="http://en.wikipedia.org/wiki/Purely_functional">单纯功能</a>的核心，里面没有可变对象，没有状态，而且没有副作用，像I/O。</p>

<p>我们可以在<em>Objective-C</em>编程中借鉴这个。在可能的情况下使用不可变对象，我们的项目将变得更容易测试。<a href="https://www.destroyallsoftware.com/talks/boundaries">Gary Bernhardt有一个很棒的讨论</a>，显示了如何使用不可变对象来帮助我们写出更好的软件。在这个讨论中，他使用的是<em>Ruby</em>，但是其概念也同样适用于<em>Objective-C</em>语言。</p>

<h3>进一步阅读</h3>

<ul>
<li><a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/CocoaEncyclopedia/ObjectMutability/ObjectMutability.html#//apple_ref/doc/uid/TP40010810-CH5-SW1">Cocoa Encyclopedia: Object Mutability</a></li>
<li><a href="http://garbagecollective.quora.com/Mutability-aliasing-and-the-caches-you-didnt-know-you-had">Mutability and Caching</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
